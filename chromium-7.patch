diff --git a/ui/base/BUILD.gn b/ui/base/BUILD.gn
index 0364813ec748e..c760dc46c4651 100644
--- a/ui/base/BUILD.gn
+++ b/ui/base/BUILD.gn
@@ -453,9 +453,12 @@ jumbo_component("base") {
     deps += [ "//ui/events" ]
   }
 
+  if (use_x11 || ozone_platform_x11) {
+    configs += [ "//build/config/linux:x11" ]
+  }
+
   if (use_x11) {
     public_deps += [ "//ui/base/x" ]
-    configs += [ "//build/config/linux:x11" ]
 
     if (!is_chromeos) {
       sources += [
@@ -469,30 +472,44 @@ jumbo_component("base") {
     }
   }
 
-  if (use_x11 && use_aura) {
+  if ((use_x11 || ozone_platform_x11) && use_aura) {
     sources += [
-      "cursor/cursor_loader_x11.cc",
-      "cursor/cursor_loader_x11.h",
-      "cursor/cursor_x11.cc",
-      "x/selection_owner.cc",
-      "x/selection_owner.h",
-      "x/selection_requestor.cc",
-      "x/selection_requestor.h",
       "x/selection_utils.cc",
       "x/selection_utils.h",
-    ]
-    deps += [
-      "//ui/events/platform/x11",
-      "//ui/gfx/x",
+      "x/selection_owner.cc",
+      "x/selection_owner.h",
     ]
 
     if (!is_chromeos) {
       # These Aura X11 files aren't used on ChromeOS.
       sources += [
-        "dragdrop/os_exchange_data_provider_aurax11.cc",
-        "dragdrop/os_exchange_data_provider_aurax11.h",
+        "dragdrop/os_exchange_data_provider_aurax11_base.cc",
+        "dragdrop/os_exchange_data_provider_aurax11_base.h",
       ]
     }
+
+    if (use_x11 && use_aura) {
+      sources += [
+        "cursor/cursor_loader_x11.cc",
+        "cursor/cursor_loader_x11.h",
+        "cursor/cursor_x11.cc",
+        "x/selection_requestor.cc",
+        "x/selection_requestor.h",
+      ]
+
+      if (!is_chromeos) {
+        # These Aura X11 files aren't used on ChromeOS.
+        sources += [
+          "dragdrop/os_exchange_data_provider_aurax11.cc",
+          "dragdrop/os_exchange_data_provider_aurax11.h",
+        ]
+      }
+    }
+
+    deps += [
+      "//ui/events/platform/x11",
+      "//ui/gfx/x",
+    ]
   }
 
   if (use_aura) {
diff --git a/ui/base/dragdrop/os_exchange_data_provider_aurax11.cc b/ui/base/dragdrop/os_exchange_data_provider_aurax11.cc
index 144c8babf5000..4543984f1210b 100644
--- a/ui/base/dragdrop/os_exchange_data_provider_aurax11.cc
+++ b/ui/base/dragdrop/os_exchange_data_provider_aurax11.cc
@@ -7,14 +7,6 @@
 #include <utility>
 
 #include "base/logging.h"
-#include "base/memory/ref_counted_memory.h"
-#include "base/strings/string_split.h"
-#include "base/strings/string_util.h"
-#include "base/strings/utf_string_conversions.h"
-#include "net/base/filename_util.h"
-#include "ui/base/clipboard/clipboard.h"
-#include "ui/base/clipboard/scoped_clipboard_writer.h"
-#include "ui/base/dragdrop/file_info.h"
 #include "ui/base/x/selection_utils.h"
 #include "ui/events/platform/platform_event_source.h"
 #include "ui/gfx/x/x11_atom_cache.h"
@@ -26,68 +18,19 @@
 
 namespace ui {
 
-namespace {
-
-const char kDndSelection[] = "XdndSelection";
-const char kRendererTaint[] = "chromium/x-renderer-taint";
-
-const char kNetscapeURL[] = "_NETSCAPE_URL";
-
-}  // namespace
-
 OSExchangeDataProviderAuraX11::OSExchangeDataProviderAuraX11(
     ::Window x_window,
     const SelectionFormatMap& selection)
-    : x_display_(gfx::GetXDisplay()),
-      x_root_window_(DefaultRootWindow(x_display_)),
-      own_window_(false),
-      x_window_(x_window),
-      format_map_(selection),
-      selection_owner_(x_display_, x_window_, gfx::GetAtom(kDndSelection)) {}
+    : OSExchangeDataProviderAuraX11Base(x_window, selection) {}
 
 OSExchangeDataProviderAuraX11::OSExchangeDataProviderAuraX11()
-    : x_display_(gfx::GetXDisplay()),
-      x_root_window_(DefaultRootWindow(x_display_)),
-      own_window_(true),
-      x_window_(XCreateWindow(x_display_,
-                              x_root_window_,
-                              -100,
-                              -100,
-                              10,
-                              10,              // x, y, width, height
-                              0,               // border width
-                              CopyFromParent,  // depth
-                              InputOnly,
-                              CopyFromParent,  // visual
-                              0,
-                              NULL)),
-      format_map_(),
-      selection_owner_(x_display_, x_window_, gfx::GetAtom(kDndSelection)) {
-  XStoreName(x_display_, x_window_, "Chromium Drag & Drop Window");
-
+    : OSExchangeDataProviderAuraX11Base() {
   PlatformEventSource::GetInstance()->AddPlatformEventDispatcher(this);
 }
 
 OSExchangeDataProviderAuraX11::~OSExchangeDataProviderAuraX11() {
-  if (own_window_) {
+  if (own_window_)
     PlatformEventSource::GetInstance()->RemovePlatformEventDispatcher(this);
-    XDestroyWindow(x_display_, x_window_);
-  }
-}
-
-void OSExchangeDataProviderAuraX11::TakeOwnershipOfSelection() const {
-  selection_owner_.TakeOwnershipOfSelection(format_map_);
-}
-
-void OSExchangeDataProviderAuraX11::RetrieveTargets(
-    std::vector<Atom>* targets) const {
-  selection_owner_.RetrieveTargets(targets);
-}
-
-SelectionFormatMap OSExchangeDataProviderAuraX11::GetFormatMap() const {
-  // We return the |selection_owner_|'s format map instead of our own in case
-  // ours has been modified since TakeOwnershipOfSelection() was called.
-  return selection_owner_.selection_format_map();
 }
 
 std::unique_ptr<OSExchangeData::Provider>
@@ -98,301 +41,6 @@ OSExchangeDataProviderAuraX11::Clone() const {
   return std::move(ret);
 }
 
-void OSExchangeDataProviderAuraX11::MarkOriginatedFromRenderer() {
-  std::string empty;
-  format_map_.Insert(gfx::GetAtom(kRendererTaint),
-                     scoped_refptr<base::RefCountedMemory>(
-                         base::RefCountedString::TakeString(&empty)));
-}
-
-bool OSExchangeDataProviderAuraX11::DidOriginateFromRenderer() const {
-  return format_map_.find(gfx::GetAtom(kRendererTaint)) != format_map_.end();
-}
-
-void OSExchangeDataProviderAuraX11::SetString(const base::string16& text_data) {
-  if (HasString())
-    return;
-
-  std::string utf8 = base::UTF16ToUTF8(text_data);
-  scoped_refptr<base::RefCountedMemory> mem(
-      base::RefCountedString::TakeString(&utf8));
-
-  format_map_.Insert(gfx::GetAtom(Clipboard::kMimeTypeText), mem);
-  format_map_.Insert(gfx::GetAtom(kText), mem);
-  format_map_.Insert(gfx::GetAtom(kString), mem);
-  format_map_.Insert(gfx::GetAtom(kUtf8String), mem);
-}
-
-void OSExchangeDataProviderAuraX11::SetURL(const GURL& url,
-                                           const base::string16& title) {
-  // TODO(dcheng): The original GTK code tries very hard to avoid writing out an
-  // empty title. Is this necessary?
-  if (url.is_valid()) {
-    // Mozilla's URL format: (UTF16: URL, newline, title)
-    base::string16 spec = base::UTF8ToUTF16(url.spec());
-
-    std::vector<unsigned char> data;
-    ui::AddString16ToVector(spec, &data);
-    ui::AddString16ToVector(base::ASCIIToUTF16("\n"), &data);
-    ui::AddString16ToVector(title, &data);
-    scoped_refptr<base::RefCountedMemory> mem(
-        base::RefCountedBytes::TakeVector(&data));
-
-    format_map_.Insert(gfx::GetAtom(Clipboard::kMimeTypeMozillaURL), mem);
-
-    // Set a string fallback as well.
-    SetString(spec);
-
-    // Return early if this drag already contains file contents (this implies
-    // that file contents must be populated before URLs). Nautilus (and possibly
-    // other file managers) prefer _NETSCAPE_URL over the X Direct Save
-    // protocol, but we want to prioritize XDS in this case.
-    if (!file_contents_name_.empty())
-      return;
-
-    // Set _NETSCAPE_URL for file managers like Nautilus that use it as a hint
-    // to create a link to the URL. Setting text/uri-list doesn't work because
-    // Nautilus will fetch and copy the contents of the URL to the drop target
-    // instead of linking...
-    // Format is UTF8: URL + "\n" + title.
-    std::string netscape_url = url.spec();
-    netscape_url += "\n";
-    netscape_url += base::UTF16ToUTF8(title);
-    format_map_.Insert(gfx::GetAtom(kNetscapeURL),
-                       scoped_refptr<base::RefCountedMemory>(
-                           base::RefCountedString::TakeString(&netscape_url)));
-  }
-}
-
-void OSExchangeDataProviderAuraX11::SetFilename(const base::FilePath& path) {
-  std::vector<FileInfo> data;
-  data.push_back(FileInfo(path, base::FilePath()));
-  SetFilenames(data);
-}
-
-void OSExchangeDataProviderAuraX11::SetFilenames(
-    const std::vector<FileInfo>& filenames) {
-  std::vector<std::string> paths;
-  for (const auto& filename : filenames) {
-    std::string url_spec = net::FilePathToFileURL(filename.path).spec();
-    if (!url_spec.empty())
-      paths.push_back(url_spec);
-  }
-
-  std::string joined_data = base::JoinString(paths, "\n");
-  scoped_refptr<base::RefCountedMemory> mem(
-      base::RefCountedString::TakeString(&joined_data));
-  format_map_.Insert(gfx::GetAtom(Clipboard::kMimeTypeURIList), mem);
-}
-
-void OSExchangeDataProviderAuraX11::SetPickledData(
-    const Clipboard::FormatType& format,
-    const base::Pickle& pickle) {
-  const unsigned char* data =
-      reinterpret_cast<const unsigned char*>(pickle.data());
-
-  std::vector<unsigned char> bytes;
-  bytes.insert(bytes.end(), data, data + pickle.size());
-  scoped_refptr<base::RefCountedMemory> mem(
-      base::RefCountedBytes::TakeVector(&bytes));
-
-  format_map_.Insert(gfx::GetAtom(format.ToString().c_str()), mem);
-}
-
-bool OSExchangeDataProviderAuraX11::GetString(base::string16* result) const {
-  if (HasFile()) {
-    // Various Linux file managers both pass a list of file:// URIs and set the
-    // string representation to the URI. We explicitly don't want to return use
-    // this representation.
-    return false;
-  }
-
-  std::vector<::Atom> text_atoms = ui::GetTextAtomsFrom();
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(text_atoms, GetTargets(), &requested_types);
-
-  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
-  if (data.IsValid()) {
-    std::string text = data.GetText();
-    *result = base::UTF8ToUTF16(text);
-    return true;
-  }
-
-  return false;
-}
-
-bool OSExchangeDataProviderAuraX11::GetURLAndTitle(
-    OSExchangeData::FilenameToURLPolicy policy,
-    GURL* url,
-    base::string16* title) const {
-  std::vector<::Atom> url_atoms = ui::GetURLAtomsFrom();
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
-
-  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
-  if (data.IsValid()) {
-    // TODO(erg): Technically, both of these forms can accept multiple URLs,
-    // but that doesn't match the assumptions of the rest of the system which
-    // expect single types.
-
-    if (data.GetType() == gfx::GetAtom(Clipboard::kMimeTypeMozillaURL)) {
-      // Mozilla URLs are (UTF16: URL, newline, title).
-      base::string16 unparsed;
-      data.AssignTo(&unparsed);
-
-      std::vector<base::string16> tokens = base::SplitString(
-          unparsed, base::ASCIIToUTF16("\n"),
-          base::KEEP_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
-      if (tokens.size() > 0) {
-        if (tokens.size() > 1)
-          *title = tokens[1];
-        else
-          *title = base::string16();
-
-        *url = GURL(tokens[0]);
-        return true;
-      }
-    } else if (data.GetType() == gfx::GetAtom(Clipboard::kMimeTypeURIList)) {
-      std::vector<std::string> tokens = ui::ParseURIList(data);
-      for (const std::string& token : tokens) {
-        GURL test_url(token);
-        if (!test_url.SchemeIsFile() ||
-            policy == OSExchangeData::CONVERT_FILENAMES) {
-          *url = test_url;
-          *title = base::string16();
-          return true;
-        }
-      }
-    }
-  }
-
-  return false;
-}
-
-bool OSExchangeDataProviderAuraX11::GetFilename(base::FilePath* path) const {
-  std::vector<FileInfo> filenames;
-  if (GetFilenames(&filenames)) {
-    *path = filenames.front().path;
-    return true;
-  }
-
-  return false;
-}
-
-bool OSExchangeDataProviderAuraX11::GetFilenames(
-    std::vector<FileInfo>* filenames) const {
-  std::vector<::Atom> url_atoms = ui::GetURIListAtomsFrom();
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
-
-  filenames->clear();
-  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
-  if (data.IsValid()) {
-    std::vector<std::string> tokens = ui::ParseURIList(data);
-    for (const std::string& token : tokens) {
-      GURL url(token);
-      base::FilePath file_path;
-      if (url.SchemeIsFile() && net::FileURLToFilePath(url, &file_path)) {
-        filenames->push_back(FileInfo(file_path, base::FilePath()));
-      }
-    }
-  }
-
-  return !filenames->empty();
-}
-
-bool OSExchangeDataProviderAuraX11::GetPickledData(
-    const Clipboard::FormatType& format,
-    base::Pickle* pickle) const {
-  std::vector< ::Atom> requested_types;
-  requested_types.push_back(gfx::GetAtom(format.ToString().c_str()));
-
-  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
-  if (data.IsValid()) {
-    // Note that the pickle object on the right hand side of the assignment
-    // only refers to the bytes in |data|. The assignment copies the data.
-    *pickle = base::Pickle(reinterpret_cast<const char*>(data.GetData()),
-                           static_cast<int>(data.GetSize()));
-    return true;
-  }
-
-  return false;
-}
-
-bool OSExchangeDataProviderAuraX11::HasString() const {
-  std::vector<::Atom> text_atoms = ui::GetTextAtomsFrom();
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(text_atoms, GetTargets(), &requested_types);
-  return !requested_types.empty() && !HasFile();
-}
-
-bool OSExchangeDataProviderAuraX11::HasURL(
-    OSExchangeData::FilenameToURLPolicy policy) const {
-  std::vector<::Atom> url_atoms = ui::GetURLAtomsFrom();
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
-
-  if (requested_types.empty())
-    return false;
-
-  // The Linux desktop doesn't differentiate between files and URLs like
-  // Windows does and stuffs all the data into one mime type.
-  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
-  if (data.IsValid()) {
-    if (data.GetType() == gfx::GetAtom(Clipboard::kMimeTypeMozillaURL)) {
-      // File managers shouldn't be using this type, so this is a URL.
-      return true;
-    } else if (data.GetType() ==
-               gfx::GetAtom(ui::Clipboard::kMimeTypeURIList)) {
-      std::vector<std::string> tokens = ui::ParseURIList(data);
-      for (const std::string& token : tokens) {
-        if (!GURL(token).SchemeIsFile() ||
-            policy == OSExchangeData::CONVERT_FILENAMES)
-          return true;
-      }
-
-      return false;
-    }
-  }
-
-  return false;
-}
-
-bool OSExchangeDataProviderAuraX11::HasFile() const {
-  std::vector<::Atom> url_atoms = ui::GetURIListAtomsFrom();
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
-
-  if (requested_types.empty())
-    return false;
-
-  // To actually answer whether we have a file, we need to look through the
-  // contents of the kMimeTypeURIList type, and see if any of them are file://
-  // URIs.
-  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
-  if (data.IsValid()) {
-    std::vector<std::string> tokens = ui::ParseURIList(data);
-    for (const std::string& token : tokens) {
-      GURL url(token);
-      base::FilePath file_path;
-      if (url.SchemeIsFile() && net::FileURLToFilePath(url, &file_path))
-        return true;
-    }
-  }
-
-  return false;
-}
-
-bool OSExchangeDataProviderAuraX11::HasCustomFormat(
-    const Clipboard::FormatType& format) const {
-  std::vector< ::Atom> url_atoms;
-  url_atoms.push_back(gfx::GetAtom(format.ToString().c_str()));
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
-
-  return !requested_types.empty();
-}
-
 void OSExchangeDataProviderAuraX11::SetFileContents(
     const base::FilePath& filename,
     const std::string& file_contents) {
@@ -428,60 +76,6 @@ void OSExchangeDataProviderAuraX11::SetFileContents(
           base::RefCountedString::TakeString(&file_contents_copy)));
 }
 
-void OSExchangeDataProviderAuraX11::SetHtml(const base::string16& html,
-                                            const GURL& base_url) {
-  std::vector<unsigned char> bytes;
-  // Manually jam a UTF16 BOM into bytes because otherwise, other programs will
-  // assume UTF-8.
-  bytes.push_back(0xFF);
-  bytes.push_back(0xFE);
-  ui::AddString16ToVector(html, &bytes);
-  scoped_refptr<base::RefCountedMemory> mem(
-      base::RefCountedBytes::TakeVector(&bytes));
-
-  format_map_.Insert(gfx::GetAtom(Clipboard::kMimeTypeHTML), mem);
-}
-
-bool OSExchangeDataProviderAuraX11::GetHtml(base::string16* html,
-                                            GURL* base_url) const {
-  std::vector< ::Atom> url_atoms;
-  url_atoms.push_back(gfx::GetAtom(Clipboard::kMimeTypeHTML));
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
-
-  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
-  if (data.IsValid()) {
-    *html = data.GetHtml();
-    *base_url = GURL();
-    return true;
-  }
-
-  return false;
-}
-
-bool OSExchangeDataProviderAuraX11::HasHtml() const {
-  std::vector< ::Atom> url_atoms;
-  url_atoms.push_back(gfx::GetAtom(Clipboard::kMimeTypeHTML));
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
-
-  return !requested_types.empty();
-}
-
-void OSExchangeDataProviderAuraX11::SetDragImage(
-    const gfx::ImageSkia& image,
-    const gfx::Vector2d& cursor_offset) {
-  drag_image_ = image;
-  drag_image_offset_ = cursor_offset;
-}
-
-gfx::ImageSkia OSExchangeDataProviderAuraX11::GetDragImage() const {
-  return drag_image_;
-}
-
-gfx::Vector2d OSExchangeDataProviderAuraX11::GetDragImageOffset() const {
-  return drag_image_offset_;
-}
 
 bool OSExchangeDataProviderAuraX11::CanDispatchEvent(
     const PlatformEvent& event) {
@@ -501,21 +95,4 @@ uint32_t OSExchangeDataProviderAuraX11::DispatchEvent(
   return ui::POST_DISPATCH_NONE;
 }
 
-bool OSExchangeDataProviderAuraX11::GetPlainTextURL(GURL* url) const {
-  base::string16 text;
-  if (GetString(&text)) {
-    GURL test_url(text);
-    if (test_url.is_valid()) {
-      *url = test_url;
-      return true;
-    }
-  }
-
-  return false;
-}
-
-std::vector< ::Atom> OSExchangeDataProviderAuraX11::GetTargets() const {
-  return format_map_.GetTypes();
-}
-
 }  // namespace ui
diff --git a/ui/base/dragdrop/os_exchange_data_provider_aurax11.h b/ui/base/dragdrop/os_exchange_data_provider_aurax11.h
index f8e60b31ac610..472984b08eb1d 100644
--- a/ui/base/dragdrop/os_exchange_data_provider_aurax11.h
+++ b/ui/base/dragdrop/os_exchange_data_provider_aurax11.h
@@ -5,30 +5,14 @@
 #ifndef UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_AURAX11_H_
 #define UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_AURAX11_H_
 
-#include <stdint.h>
-#include <map>
-
-#include "base/files/file_path.h"
-#include "base/macros.h"
-#include "base/pickle.h"
-#include "ui/base/dragdrop/os_exchange_data.h"
-#include "ui/base/x/selection_owner.h"
-#include "ui/base/x/selection_requestor.h"
-#include "ui/base/x/selection_utils.h"
+#include "ui/base/dragdrop/os_exchange_data_provider_aurax11_base.h"
 #include "ui/events/platform/platform_event_dispatcher.h"
-#include "ui/gfx/geometry/vector2d.h"
-#include "ui/gfx/image/image_skia.h"
-#include "ui/gfx/x/x11.h"
-#include "url/gurl.h"
 
 namespace ui {
 
-class Clipboard;
-class OSExchangeDataProviderAuraX11Test;
-
 // OSExchangeData::Provider implementation for aura on linux.
 class UI_BASE_EXPORT OSExchangeDataProviderAuraX11
-    : public OSExchangeData::Provider,
+    : public OSExchangeDataProviderAuraX11Base,
       public PlatformEventDispatcher {
  public:
   // |x_window| is the window the cursor is over, and |selection| is the set of
@@ -42,99 +26,15 @@ class UI_BASE_EXPORT OSExchangeDataProviderAuraX11
 
   ~OSExchangeDataProviderAuraX11() override;
 
-  // After all the Set* methods have built up the data we're offering, call
-  // this to take ownership of the XdndSelection clipboard.
-  void TakeOwnershipOfSelection() const;
-
-  // Retrieves a list of types we're offering. Noop if we haven't taken the
-  // selection.
-  void RetrieveTargets(std::vector<Atom>* targets) const;
-
-  // Makes a copy of the format map currently being offered.
-  SelectionFormatMap GetFormatMap() const;
-
-  const base::FilePath& file_contents_name() const {
-    return file_contents_name_;
-  }
-
-  // Overridden from OSExchangeData::Provider:
   std::unique_ptr<Provider> Clone() const override;
-  void MarkOriginatedFromRenderer() override;
-  bool DidOriginateFromRenderer() const override;
-  void SetString(const base::string16& data) override;
-  void SetURL(const GURL& url, const base::string16& title) override;
-  void SetFilename(const base::FilePath& path) override;
-  void SetFilenames(const std::vector<FileInfo>& filenames) override;
-  void SetPickledData(const Clipboard::FormatType& format,
-                      const base::Pickle& pickle) override;
-  bool GetString(base::string16* data) const override;
-  bool GetURLAndTitle(OSExchangeData::FilenameToURLPolicy policy,
-                      GURL* url,
-                      base::string16* title) const override;
-  bool GetFilename(base::FilePath* path) const override;
-  bool GetFilenames(std::vector<FileInfo>* filenames) const override;
-  bool GetPickledData(const Clipboard::FormatType& format,
-                      base::Pickle* pickle) const override;
-  bool HasString() const override;
-  bool HasURL(OSExchangeData::FilenameToURLPolicy policy) const override;
-  bool HasFile() const override;
-  bool HasCustomFormat(const Clipboard::FormatType& format) const override;
-
   void SetFileContents(const base::FilePath& filename,
                        const std::string& file_contents) override;
 
-  void SetHtml(const base::string16& html, const GURL& base_url) override;
-  bool GetHtml(base::string16* html, GURL* base_url) const override;
-  bool HasHtml() const override;
-  void SetDragImage(const gfx::ImageSkia& image,
-                    const gfx::Vector2d& cursor_offset) override;
-  gfx::ImageSkia GetDragImage() const override;
-  gfx::Vector2d GetDragImageOffset() const override;
-
   // PlatformEventDispatcher:
   bool CanDispatchEvent(const PlatformEvent& event) override;
   uint32_t DispatchEvent(const PlatformEvent& event) override;
 
  private:
-  friend class OSExchangeDataProviderAuraX11Test;
-  typedef std::map<Clipboard::FormatType, base::Pickle> PickleData;
-
-  // Returns true if |formats_| contains a string format and the string can be
-  // parsed as a URL.
-  bool GetPlainTextURL(GURL* url) const;
-
-  // Returns the targets in |format_map_|.
-  std::vector< ::Atom> GetTargets() const;
-
-  // Drag image and offset data.
-  gfx::ImageSkia drag_image_;
-  gfx::Vector2d drag_image_offset_;
-
-  // Our X11 state.
-  Display* x_display_;
-  ::Window x_root_window_;
-
-  // In X11, because the IPC parts of drag operations are implemented by
-  // XSelection, we require an x11 window to receive drag messages on. The
-  // OSExchangeDataProvider system is modeled on the Windows implementation,
-  // which does not require a window. We only sometimes have a valid window
-  // available (in the case of drag receiving). Other times, we need to create
-  // our own xwindow just to receive events on it.
-  const bool own_window_;
-
-  ::Window x_window_;
-
-  // A representation of data. This is either passed to us from the other
-  // process, or built up through a sequence of Set*() calls. It can be passed
-  // to |selection_owner_| when we take the selection.
-  SelectionFormatMap format_map_;
-
-  // Auxilary data for the X Direct Save protocol.
-  base::FilePath file_contents_name_;
-
-  // Takes a snapshot of |format_map_| and offers it to other windows.
-  mutable SelectionOwner selection_owner_;
-
   DISALLOW_COPY_AND_ASSIGN(OSExchangeDataProviderAuraX11);
 };
 
diff --git a/ui/base/dragdrop/os_exchange_data_provider_aurax11_base.cc b/ui/base/dragdrop/os_exchange_data_provider_aurax11_base.cc
new file mode 100644
index 0000000000000..353067f972e69
--- /dev/null
+++ b/ui/base/dragdrop/os_exchange_data_provider_aurax11_base.cc
@@ -0,0 +1,460 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/dragdrop/os_exchange_data_provider_aurax11_base.h"
+
+#include <utility>
+
+#include "base/logging.h"
+#include "base/memory/ref_counted_memory.h"
+#include "base/strings/string_split.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "net/base/filename_util.h"
+#include "ui/base/clipboard/clipboard.h"
+#include "ui/base/clipboard/scoped_clipboard_writer.h"
+#include "ui/base/dragdrop/file_info.h"
+#include "ui/base/x/selection_utils.h"
+#include "ui/events/platform/platform_event_source.h"
+#include "ui/gfx/x/x11_atom_cache.h"
+
+// Note: the GetBlah() methods are used immediately by the
+// web_contents_view_aura.cc:PrepareDropData(), while the omnibox is a
+// little more discriminating and calls HasBlah() before trying to get the
+// information.
+
+namespace ui {
+
+namespace {
+
+const char kDndSelection[] = "XdndSelection";
+const char kRendererTaint[] = "chromium/x-renderer-taint";
+
+const char kNetscapeURL[] = "_NETSCAPE_URL";
+
+}  // namespace
+
+OSExchangeDataProviderAuraX11Base::OSExchangeDataProviderAuraX11Base(
+    ::Window x_window,
+    const SelectionFormatMap& selection)
+    : x_display_(gfx::GetXDisplay()),
+      x_root_window_(DefaultRootWindow(x_display_)),
+      own_window_(false),
+      x_window_(x_window),
+      format_map_(selection),
+      selection_owner_(x_display_, x_window_, gfx::GetAtom(kDndSelection)) {}
+
+OSExchangeDataProviderAuraX11Base::OSExchangeDataProviderAuraX11Base()
+    : x_display_(gfx::GetXDisplay()),
+      x_root_window_(DefaultRootWindow(x_display_)),
+      own_window_(true),
+      x_window_(XCreateWindow(x_display_,
+                              x_root_window_,
+                              -100,
+                              -100,
+                              10,
+                              10,              // x, y, width, height
+                              0,               // border width
+                              CopyFromParent,  // depth
+                              InputOnly,
+                              CopyFromParent,  // visual
+                              0,
+                              NULL)),
+      format_map_(),
+      selection_owner_(x_display_, x_window_, gfx::GetAtom(kDndSelection)) {
+  XStoreName(x_display_, x_window_, "Chromium Drag & Drop Window");
+}
+
+OSExchangeDataProviderAuraX11Base::~OSExchangeDataProviderAuraX11Base() {
+  if (own_window_)
+    XDestroyWindow(x_display_, x_window_);
+}
+
+void OSExchangeDataProviderAuraX11Base::TakeOwnershipOfSelection() const {
+  selection_owner_.TakeOwnershipOfSelection(format_map_);
+}
+
+void OSExchangeDataProviderAuraX11Base::RetrieveTargets(
+    std::vector<Atom>* targets) const {
+  selection_owner_.RetrieveTargets(targets);
+}
+
+SelectionFormatMap OSExchangeDataProviderAuraX11Base::GetFormatMap() const {
+  // We return the |selection_owner_|'s format map instead of our own in case
+  // ours has been modified since TakeOwnershipOfSelection() was called.
+  return selection_owner_.selection_format_map();
+}
+
+void OSExchangeDataProviderAuraX11Base::MarkOriginatedFromRenderer() {
+  std::string empty;
+  format_map_.Insert(gfx::GetAtom(kRendererTaint),
+                     scoped_refptr<base::RefCountedMemory>(
+                         base::RefCountedString::TakeString(&empty)));
+}
+
+bool OSExchangeDataProviderAuraX11Base::DidOriginateFromRenderer() const {
+  return format_map_.find(gfx::GetAtom(kRendererTaint)) != format_map_.end();
+}
+
+void OSExchangeDataProviderAuraX11Base::SetString(
+    const base::string16& text_data) {
+  if (HasString())
+    return;
+
+  std::string utf8 = base::UTF16ToUTF8(text_data);
+  scoped_refptr<base::RefCountedMemory> mem(
+      base::RefCountedString::TakeString(&utf8));
+
+  format_map_.Insert(gfx::GetAtom(Clipboard::kMimeTypeText), mem);
+  format_map_.Insert(gfx::GetAtom(kText), mem);
+  format_map_.Insert(gfx::GetAtom(kString), mem);
+  format_map_.Insert(gfx::GetAtom(kUtf8String), mem);
+}
+
+void OSExchangeDataProviderAuraX11Base::SetURL(const GURL& url,
+                                               const base::string16& title) {
+  // TODO(dcheng): The original GTK code tries very hard to avoid writing out an
+  // empty title. Is this necessary?
+  if (url.is_valid()) {
+    // Mozilla's URL format: (UTF16: URL, newline, title)
+    base::string16 spec = base::UTF8ToUTF16(url.spec());
+
+    std::vector<unsigned char> data;
+    ui::AddString16ToVector(spec, &data);
+    ui::AddString16ToVector(base::ASCIIToUTF16("\n"), &data);
+    ui::AddString16ToVector(title, &data);
+    scoped_refptr<base::RefCountedMemory> mem(
+        base::RefCountedBytes::TakeVector(&data));
+
+    format_map_.Insert(gfx::GetAtom(Clipboard::kMimeTypeMozillaURL), mem);
+
+    // Set a string fallback as well.
+    SetString(spec);
+
+    // Return early if this drag already contains file contents (this implies
+    // that file contents must be populated before URLs). Nautilus (and possibly
+    // other file managers) prefer _NETSCAPE_URL over the X Direct Save
+    // protocol, but we want to prioritize XDS in this case.
+    if (!file_contents_name_.empty())
+      return;
+
+    // Set _NETSCAPE_URL for file managers like Nautilus that use it as a hint
+    // to create a link to the URL. Setting text/uri-list doesn't work because
+    // Nautilus will fetch and copy the contents of the URL to the drop target
+    // instead of linking...
+    // Format is UTF8: URL + "\n" + title.
+    std::string netscape_url = url.spec();
+    netscape_url += "\n";
+    netscape_url += base::UTF16ToUTF8(title);
+    format_map_.Insert(gfx::GetAtom(kNetscapeURL),
+                       scoped_refptr<base::RefCountedMemory>(
+                           base::RefCountedString::TakeString(&netscape_url)));
+  }
+}
+
+void OSExchangeDataProviderAuraX11Base::SetFilename(
+    const base::FilePath& path) {
+  std::vector<FileInfo> data;
+  data.push_back(FileInfo(path, base::FilePath()));
+  SetFilenames(data);
+}
+
+void OSExchangeDataProviderAuraX11Base::SetFilenames(
+    const std::vector<FileInfo>& filenames) {
+  std::vector<std::string> paths;
+  for (const auto& filename : filenames) {
+    std::string url_spec = net::FilePathToFileURL(filename.path).spec();
+    if (!url_spec.empty())
+      paths.push_back(url_spec);
+  }
+
+  std::string joined_data = base::JoinString(paths, "\n");
+  scoped_refptr<base::RefCountedMemory> mem(
+      base::RefCountedString::TakeString(&joined_data));
+  format_map_.Insert(gfx::GetAtom(Clipboard::kMimeTypeURIList), mem);
+}
+
+void OSExchangeDataProviderAuraX11Base::SetPickledData(
+    const Clipboard::FormatType& format,
+    const base::Pickle& pickle) {
+  const unsigned char* data =
+      reinterpret_cast<const unsigned char*>(pickle.data());
+
+  std::vector<unsigned char> bytes;
+  bytes.insert(bytes.end(), data, data + pickle.size());
+  scoped_refptr<base::RefCountedMemory> mem(
+      base::RefCountedBytes::TakeVector(&bytes));
+
+  format_map_.Insert(gfx::GetAtom(format.ToString().c_str()), mem);
+}
+
+bool OSExchangeDataProviderAuraX11Base::GetString(
+    base::string16* result) const {
+  if (HasFile()) {
+    // Various Linux file managers both pass a list of file:// URIs and set the
+    // string representation to the URI. We explicitly don't want to return use
+    // this representation.
+    return false;
+  }
+
+  std::vector<::Atom> text_atoms = ui::GetTextAtomsFrom();
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(text_atoms, GetTargets(), &requested_types);
+
+  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
+  if (data.IsValid()) {
+    std::string text = data.GetText();
+    *result = base::UTF8ToUTF16(text);
+    return true;
+  }
+
+  return false;
+}
+
+bool OSExchangeDataProviderAuraX11Base::GetURLAndTitle(
+    OSExchangeData::FilenameToURLPolicy policy,
+    GURL* url,
+    base::string16* title) const {
+  std::vector<::Atom> url_atoms = ui::GetURLAtomsFrom();
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
+
+  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
+  if (data.IsValid()) {
+    // TODO(erg): Technically, both of these forms can accept multiple URLs,
+    // but that doesn't match the assumptions of the rest of the system which
+    // expect single types.
+
+    if (data.GetType() == gfx::GetAtom(Clipboard::kMimeTypeMozillaURL)) {
+      // Mozilla URLs are (UTF16: URL, newline, title).
+      base::string16 unparsed;
+      data.AssignTo(&unparsed);
+
+      std::vector<base::string16> tokens =
+          base::SplitString(unparsed, base::ASCIIToUTF16("\n"),
+                            base::KEEP_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
+      if (tokens.size() > 0) {
+        if (tokens.size() > 1)
+          *title = tokens[1];
+        else
+          *title = base::string16();
+
+        *url = GURL(tokens[0]);
+        return true;
+      }
+    } else if (data.GetType() == gfx::GetAtom(Clipboard::kMimeTypeURIList)) {
+      std::vector<std::string> tokens = ui::ParseURIList(data);
+      for (const std::string& token : tokens) {
+        GURL test_url(token);
+        if (!test_url.SchemeIsFile() ||
+            policy == OSExchangeData::CONVERT_FILENAMES) {
+          *url = test_url;
+          *title = base::string16();
+          return true;
+        }
+      }
+    }
+  }
+
+  return false;
+}
+
+bool OSExchangeDataProviderAuraX11Base::GetFilename(
+    base::FilePath* path) const {
+  std::vector<FileInfo> filenames;
+  if (GetFilenames(&filenames)) {
+    *path = filenames.front().path;
+    return true;
+  }
+
+  return false;
+}
+
+bool OSExchangeDataProviderAuraX11Base::GetFilenames(
+    std::vector<FileInfo>* filenames) const {
+  std::vector<::Atom> url_atoms = ui::GetURIListAtomsFrom();
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
+
+  filenames->clear();
+  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
+  if (data.IsValid()) {
+    std::vector<std::string> tokens = ui::ParseURIList(data);
+    for (const std::string& token : tokens) {
+      GURL url(token);
+      base::FilePath file_path;
+      if (url.SchemeIsFile() && net::FileURLToFilePath(url, &file_path)) {
+        filenames->push_back(FileInfo(file_path, base::FilePath()));
+      }
+    }
+  }
+
+  return !filenames->empty();
+}
+
+bool OSExchangeDataProviderAuraX11Base::GetPickledData(
+    const Clipboard::FormatType& format,
+    base::Pickle* pickle) const {
+  std::vector<::Atom> requested_types;
+  requested_types.push_back(gfx::GetAtom(format.ToString().c_str()));
+
+  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
+  if (data.IsValid()) {
+    // Note that the pickle object on the right hand side of the assignment
+    // only refers to the bytes in |data|. The assignment copies the data.
+    *pickle = base::Pickle(reinterpret_cast<const char*>(data.GetData()),
+                           static_cast<int>(data.GetSize()));
+    return true;
+  }
+
+  return false;
+}
+
+bool OSExchangeDataProviderAuraX11Base::HasString() const {
+  std::vector<::Atom> text_atoms = ui::GetTextAtomsFrom();
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(text_atoms, GetTargets(), &requested_types);
+  return !requested_types.empty() && !HasFile();
+}
+
+bool OSExchangeDataProviderAuraX11Base::HasURL(
+    OSExchangeData::FilenameToURLPolicy policy) const {
+  std::vector<::Atom> url_atoms = ui::GetURLAtomsFrom();
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
+
+  if (requested_types.empty())
+    return false;
+
+  // The Linux desktop doesn't differentiate between files and URLs like
+  // Windows does and stuffs all the data into one mime type.
+  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
+  if (data.IsValid()) {
+    if (data.GetType() == gfx::GetAtom(Clipboard::kMimeTypeMozillaURL)) {
+      // File managers shouldn't be using this type, so this is a URL.
+      return true;
+    } else if (data.GetType() ==
+               gfx::GetAtom(ui::Clipboard::kMimeTypeURIList)) {
+      std::vector<std::string> tokens = ui::ParseURIList(data);
+      for (const std::string& token : tokens) {
+        if (!GURL(token).SchemeIsFile() ||
+            policy == OSExchangeData::CONVERT_FILENAMES)
+          return true;
+      }
+
+      return false;
+    }
+  }
+
+  return false;
+}
+
+bool OSExchangeDataProviderAuraX11Base::HasFile() const {
+  std::vector<::Atom> url_atoms = ui::GetURIListAtomsFrom();
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
+
+  if (requested_types.empty())
+    return false;
+
+  // To actually answer whether we have a file, we need to look through the
+  // contents of the kMimeTypeURIList type, and see if any of them are file://
+  // URIs.
+  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
+  if (data.IsValid()) {
+    std::vector<std::string> tokens = ui::ParseURIList(data);
+    for (const std::string& token : tokens) {
+      GURL url(token);
+      base::FilePath file_path;
+      if (url.SchemeIsFile() && net::FileURLToFilePath(url, &file_path))
+        return true;
+    }
+  }
+
+  return false;
+}
+
+bool OSExchangeDataProviderAuraX11Base::HasCustomFormat(
+    const Clipboard::FormatType& format) const {
+  std::vector<::Atom> url_atoms;
+  url_atoms.push_back(gfx::GetAtom(format.ToString().c_str()));
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
+
+  return !requested_types.empty();
+}
+
+void OSExchangeDataProviderAuraX11Base::SetHtml(const base::string16& html,
+                                                const GURL& base_url) {
+  std::vector<unsigned char> bytes;
+  // Manually jam a UTF16 BOM into bytes because otherwise, other programs will
+  // assume UTF-8.
+  bytes.push_back(0xFF);
+  bytes.push_back(0xFE);
+  ui::AddString16ToVector(html, &bytes);
+  scoped_refptr<base::RefCountedMemory> mem(
+      base::RefCountedBytes::TakeVector(&bytes));
+
+  format_map_.Insert(gfx::GetAtom(Clipboard::kMimeTypeHTML), mem);
+}
+
+bool OSExchangeDataProviderAuraX11Base::GetHtml(base::string16* html,
+                                                GURL* base_url) const {
+  std::vector<::Atom> url_atoms;
+  url_atoms.push_back(gfx::GetAtom(Clipboard::kMimeTypeHTML));
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
+
+  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
+  if (data.IsValid()) {
+    *html = data.GetHtml();
+    *base_url = GURL();
+    return true;
+  }
+
+  return false;
+}
+
+bool OSExchangeDataProviderAuraX11Base::HasHtml() const {
+  std::vector<::Atom> url_atoms;
+  url_atoms.push_back(gfx::GetAtom(Clipboard::kMimeTypeHTML));
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
+
+  return !requested_types.empty();
+}
+
+void OSExchangeDataProviderAuraX11Base::SetDragImage(
+    const gfx::ImageSkia& image,
+    const gfx::Vector2d& cursor_offset) {
+  drag_image_ = image;
+  drag_image_offset_ = cursor_offset;
+}
+
+gfx::ImageSkia OSExchangeDataProviderAuraX11Base::GetDragImage() const {
+  return drag_image_;
+}
+
+gfx::Vector2d OSExchangeDataProviderAuraX11Base::GetDragImageOffset() const {
+  return drag_image_offset_;
+}
+
+bool OSExchangeDataProviderAuraX11Base::GetPlainTextURL(GURL* url) const {
+  base::string16 text;
+  if (GetString(&text)) {
+    GURL test_url(text);
+    if (test_url.is_valid()) {
+      *url = test_url;
+      return true;
+    }
+  }
+
+  return false;
+}
+
+std::vector<::Atom> OSExchangeDataProviderAuraX11Base::GetTargets() const {
+  return format_map_.GetTypes();
+}
+
+}  // namespace ui
diff --git a/ui/base/dragdrop/os_exchange_data_provider_aurax11_base.h b/ui/base/dragdrop/os_exchange_data_provider_aurax11_base.h
new file mode 100644
index 0000000000000..16ff12fd84faa
--- /dev/null
+++ b/ui/base/dragdrop/os_exchange_data_provider_aurax11_base.h
@@ -0,0 +1,134 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_AURAX11_BASE_H_
+#define UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_AURAX11_BASE_H_
+
+#include <stdint.h>
+#include <map>
+
+#include "base/files/file_path.h"
+#include "base/macros.h"
+#include "base/pickle.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/base/x/selection_owner.h"
+#include "ui/base/x/selection_requestor.h"
+#include "ui/base/x/selection_utils.h"
+#include "ui/events/platform/platform_event_dispatcher.h"
+#include "ui/gfx/geometry/vector2d.h"
+#include "ui/gfx/image/image_skia.h"
+#include "ui/gfx/x/x11.h"
+#include "url/gurl.h"
+
+namespace ui {
+
+class Clipboard;
+class OSExchangeDataProviderAuraX11Test;
+
+// OSExchangeData::Provider implementation for aura on linux.
+class UI_BASE_EXPORT OSExchangeDataProviderAuraX11Base
+    : public OSExchangeData::Provider {
+ public:
+  // |x_window| is the window the cursor is over, and |selection| is the set of
+  // data being offered.
+  OSExchangeDataProviderAuraX11Base(::Window x_window,
+                                    const SelectionFormatMap& selection);
+
+  // Creates a Provider for sending drag information. This creates its own,
+  // hidden X11 window to own send data.
+  OSExchangeDataProviderAuraX11Base();
+
+  ~OSExchangeDataProviderAuraX11Base() override;
+
+  // After all the Set* methods have built up the data we're offering, call
+  // this to take ownership of the XdndSelection clipboard.
+  void TakeOwnershipOfSelection() const;
+
+  // Retrieves a list of types we're offering. Noop if we haven't taken the
+  // selection.
+  void RetrieveTargets(std::vector<Atom>* targets) const;
+
+  // Makes a copy of the format map currently being offered.
+  SelectionFormatMap GetFormatMap() const;
+
+  const base::FilePath& file_contents_name() const {
+    return file_contents_name_;
+  }
+
+  // Overridden from OSExchangeData::Provider:
+  void MarkOriginatedFromRenderer() override;
+  bool DidOriginateFromRenderer() const override;
+  void SetString(const base::string16& data) override;
+  void SetURL(const GURL& url, const base::string16& title) override;
+  void SetFilename(const base::FilePath& path) override;
+  void SetFilenames(const std::vector<FileInfo>& filenames) override;
+  void SetPickledData(const Clipboard::FormatType& format,
+                      const base::Pickle& pickle) override;
+  bool GetString(base::string16* data) const override;
+  bool GetURLAndTitle(OSExchangeData::FilenameToURLPolicy policy,
+                      GURL* url,
+                      base::string16* title) const override;
+  bool GetFilename(base::FilePath* path) const override;
+  bool GetFilenames(std::vector<FileInfo>* filenames) const override;
+  bool GetPickledData(const Clipboard::FormatType& format,
+                      base::Pickle* pickle) const override;
+  bool HasString() const override;
+  bool HasURL(OSExchangeData::FilenameToURLPolicy policy) const override;
+  bool HasFile() const override;
+  bool HasCustomFormat(const Clipboard::FormatType& format) const override;
+
+  void SetHtml(const base::string16& html, const GURL& base_url) override;
+  bool GetHtml(base::string16* html, GURL* base_url) const override;
+  bool HasHtml() const override;
+  void SetDragImage(const gfx::ImageSkia& image,
+                    const gfx::Vector2d& cursor_offset) override;
+  gfx::ImageSkia GetDragImage() const override;
+  gfx::Vector2d GetDragImageOffset() const override;
+
+ protected:
+  friend class OSExchangeDataProviderAuraX11Test;
+  typedef std::map<Clipboard::FormatType, base::Pickle> PickleData;
+
+  // Returns true if |formats_| contains a string format and the string can be
+  // parsed as a URL.
+  bool GetPlainTextURL(GURL* url) const;
+
+  // Returns the targets in |format_map_|.
+  std::vector<::Atom> GetTargets() const;
+
+  // Drag image and offset data.
+  gfx::ImageSkia drag_image_;
+  gfx::Vector2d drag_image_offset_;
+
+  // Our X11 state.
+  Display* x_display_;
+  ::Window x_root_window_;
+
+  // In X11, because the IPC parts of drag operations are implemented by
+  // XSelection, we require an x11 window to receive drag messages on. The
+  // OSExchangeDataProvider system is modeled on the Windows implementation,
+  // which does not require a window. We only sometimes have a valid window
+  // available (in the case of drag receiving). Other times, we need to create
+  // our own xwindow just to receive events on it.
+  const bool own_window_;
+
+  ::Window x_window_;
+
+  // A representation of data. This is either passed to us from the other
+  // process, or built up through a sequence of Set*() calls. It can be passed
+  // to |selection_owner_| when we take the selection.
+  SelectionFormatMap format_map_;
+
+  // Auxilary data for the X Direct Save protocol.
+  base::FilePath file_contents_name_;
+
+  // Takes a snapshot of |format_map_| and offers it to other windows.
+  mutable SelectionOwner selection_owner_;
+
+  DISALLOW_COPY_AND_ASSIGN(OSExchangeDataProviderAuraX11Base);
+};
+
+}  // namespace ui
+
+#endif  // UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_AURAX11_BASE_H_
diff --git a/ui/ozone/platform/x11/BUILD.gn b/ui/ozone/platform/x11/BUILD.gn
index 948ed961a127e..510fb452f7896 100644
--- a/ui/ozone/platform/x11/BUILD.gn
+++ b/ui/ozone/platform/x11/BUILD.gn
@@ -28,6 +28,12 @@ source_set("x11") {
     "x11_display_fetcher_ozone.h",
     "x11_screen_ozone.cc",
     "x11_screen_ozone.h",
+    "x11_drag_context.cc",
+    "x11_drag_context.h",
+    "x11_drag_source.cc",
+    "x11_drag_source.h",
+    "x11_drag_util.cc",
+    "x11_drag_util.h",
     "x11_surface_factory.cc",
     "x11_surface_factory.h",
     "x11_window_manager_ozone.cc",
diff --git a/ui/ozone/platform/x11/x11_drag_context.cc b/ui/ozone/platform/x11/x11_drag_context.cc
new file mode 100644
index 0000000000000..f94cd861fa47c
--- /dev/null
+++ b/ui/ozone/platform/x11/x11_drag_context.cc
@@ -0,0 +1,266 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/ozone/platform/x11/x11_drag_context.h"
+
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/base/dragdrop/os_exchange_data_provider_aurax11_base.h"
+#include "ui/base/x/x11_util.h"
+#include "ui/base/x/x11_window_event_manager.h"
+#include "ui/events/platform/x11/x11_event_source.h"
+#include "ui/gfx/x/x11.h"
+#include "ui/gfx/x/x11_atom_cache.h"
+#include "ui/ozone/platform/x11/x11_drag_util.h"
+#include "ui/ozone/platform/x11/x11_window_ozone.h"
+
+namespace ui {
+
+namespace {
+
+constexpr int kWillAcceptDrop = 1;
+constexpr int kWantFurtherPosEvents = 2;
+
+// Window property that will receive the drag and drop selection data.
+const char kChromiumDragReciever[] = "_CHROMIUM_DRAG_RECEIVER";
+
+}  // namespace
+
+class X11OSExchangeDataProvider : public OSExchangeDataProviderAuraX11Base {
+ public:
+  X11OSExchangeDataProvider(::Window x_window,
+                            const SelectionFormatMap& selection)
+      : OSExchangeDataProviderAuraX11Base(x_window, selection) {}
+
+  X11OSExchangeDataProvider() {}
+
+  std::unique_ptr<Provider> Clone() const override {
+    std::unique_ptr<X11OSExchangeDataProvider> ret(
+        new X11OSExchangeDataProvider());
+    ret->format_map_ = format_map_;
+    return std::move(ret);
+  }
+};
+
+X11DragContext::X11DragContext(X11WindowOzone* window,
+                               XID local_window,
+                               const XClientMessageEvent& event,
+                               const SelectionFormatMap* map)
+    : window_(window),
+      local_window_(local_window),
+      source_window_(event.data.l[0]),
+      waiting_to_handle_position_(false),
+      suggested_action_(x11::None) {
+  if (!map) {
+    bool get_types_from_property = ((event.data.l[1] & 1) != 0);
+
+    if (get_types_from_property) {
+      if (!ui::GetAtomArrayProperty(source_window_, kXdndTypeList,
+                                    &unfetched_targets_)) {
+        return;
+      }
+    } else {
+      // data.l[2,3,4] contain the first three types. Unused slots can be None.
+      for (int i = 0; i < 3; ++i) {
+        if (event.data.l[2 + i] != x11::None) {
+          unfetched_targets_.push_back(event.data.l[2 + i]);
+        }
+      }
+    }
+
+#if DCHECK_IS_ON()
+    DVLOG(1) << "XdndEnter has " << unfetched_targets_.size() << " data types";
+    for (::Atom target : unfetched_targets_) {
+      DVLOG(1) << "XdndEnter data type: " << target;
+    }
+#endif  // DCHECK_IS_ON()
+
+    // The window doesn't have a DesktopDragDropClientAura, that means it's
+    // created by some other process. Listen for messages on it.
+    source_window_events_.reset(
+        new ui::XScopedEventSelector(source_window_, PropertyChangeMask));
+
+    // We must perform a full sync here because we could be racing
+    // |source_window_|.
+    XSync(gfx::GetXDisplay(), x11::False);
+  } else {
+    // This drag originates from an aura window within our process. This means
+    // that we can shortcut the X11 server and ask the owning SelectionOwner
+    // for the data it's offering.
+    fetched_targets_ = *map;
+  }
+
+  ReadActions();
+}
+
+X11DragContext::~X11DragContext() = default;
+
+void X11DragContext::OnXdndPosition(const XClientMessageEvent& event) {
+  unsigned long source_window = event.data.l[0];
+  int x_root_window = event.data.l[2] >> 16;
+  int y_root_window = event.data.l[2] & 0xffff;
+  ::Time time_stamp = event.data.l[3];
+  ::Atom suggested_action = event.data.l[4];
+
+  OnXdndPositionMessage(suggested_action, source_window, time_stamp,
+                        gfx::PointF(x_root_window, y_root_window));
+}
+
+void X11DragContext::OnXdndPositionMessage(::Atom suggested_action,
+                                           XID source_window,
+                                           ::Time time_stamp,
+                                           const gfx::PointF& screen_point) {
+  DCHECK_EQ(source_window_, source_window);
+  suggested_action_ = suggested_action;
+
+  if (!unfetched_targets_.empty()) {
+    // We have unfetched targets. That means we need to pause the handling of
+    // the position message and ask the other window for its data.
+    screen_point_ = screen_point;
+    position_time_stamp_ = time_stamp;
+    waiting_to_handle_position_ = true;
+
+    fetched_targets_ = ui::SelectionFormatMap();
+    RequestNextTarget();
+  } else {
+    CompleteXdndPosition(source_window, screen_point);
+  }
+}
+
+void X11DragContext::RequestNextTarget() {
+  DCHECK(!unfetched_targets_.empty());
+  DCHECK(waiting_to_handle_position_);
+
+  ::Atom target = unfetched_targets_.back();
+  unfetched_targets_.pop_back();
+
+  XConvertSelection(gfx::GetXDisplay(), gfx::GetAtom(kXdndSelection), target,
+                    gfx::GetAtom(kChromiumDragReciever), local_window_,
+                    position_time_stamp_);
+}
+
+void X11DragContext::OnSelectionNotify(const XSelectionEvent& event) {
+  if (!waiting_to_handle_position_) {
+    // A misbehaved window may send SelectionNotify without us requesting data
+    // via XConvertSelection().
+    return;
+  }
+
+  DVLOG(1) << "SelectionNotify, format " << event.target;
+
+  if (event.property != x11::None) {
+    DCHECK_EQ(event.property, gfx::GetAtom(kChromiumDragReciever));
+
+    scoped_refptr<base::RefCountedMemory> data;
+    ::Atom type = x11::None;
+    if (ui::GetRawBytesOfProperty(local_window_, event.property, &data, NULL,
+                                  &type)) {
+      fetched_targets_.Insert(event.target, data);
+    }
+  } else {
+    // The source failed to convert the drop data to the format (target in X11
+    // parlance) that we asked for. This happens, even though we only ask for
+    // the formats advertised by the source. http://crbug.com/628099
+    DVLOG(1) << "XConvertSelection failed for source-advertised target "
+             << event.target;
+  }
+
+  if (!unfetched_targets_.empty()) {
+    RequestNextTarget();
+  } else {
+    waiting_to_handle_position_ = false;
+    CompleteXdndPosition(source_window_, screen_point_);
+  }
+}
+
+void X11DragContext::ReadActions() {
+  std::vector<::Atom> atom_array;
+  if (!ui::GetAtomArrayProperty(source_window_, kXdndActionList, &atom_array)) {
+    actions_.clear();
+  } else {
+    actions_.swap(atom_array);
+  }
+}
+
+int X11DragContext::GetDragOperation() const {
+  int drag_operation = ui::DragDropTypes::DRAG_NONE;
+  for (std::vector<::Atom>::const_iterator it = actions_.begin();
+       it != actions_.end(); ++it) {
+    MaskOperation(*it, &drag_operation);
+  }
+
+  MaskOperation(suggested_action_, &drag_operation);
+
+  return drag_operation;
+}
+
+void X11DragContext::MaskOperation(::Atom xdnd_operation,
+                                   int* drag_operation) const {
+  if (xdnd_operation == gfx::GetAtom(kXdndActionCopy))
+    *drag_operation |= ui::DragDropTypes::DRAG_COPY;
+  else if (xdnd_operation == gfx::GetAtom(kXdndActionMove))
+    *drag_operation |= ui::DragDropTypes::DRAG_MOVE;
+  else if (xdnd_operation == gfx::GetAtom(kXdndActionLink))
+    *drag_operation |= ui::DragDropTypes::DRAG_LINK;
+}
+
+void X11DragContext::CompleteXdndPosition(XID source_window,
+                                          const gfx::PointF& screen_point) {
+  // int drag_operation = ui::DragDropTypes::DRAG_COPY;
+  std::unique_ptr<OSExchangeData> data = std::make_unique<OSExchangeData>(
+      std::make_unique<X11OSExchangeDataProvider>(local_window_,
+                                                  fetched_targets()));
+  int drag_operation = GetDragOperation();
+  // KDE-based file browsers such as Dolphin change the drag operation depending
+  // on whether alt/ctrl/shift was pressed. However once Chromium gets control
+  // over the X11 events, the source application does no longer receive X11
+  // events for key modifier changes, so the dnd operation gets stuck in an
+  // incorrect state. Blink can only dnd-open files of type DRAG_COPY, so the
+  // DRAG_COPY mask is added if the dnd object is a file.
+  if (drag_operation &
+          (ui::DragDropTypes::DRAG_MOVE | ui::DragDropTypes::DRAG_LINK) &&
+      data->HasFile()) {
+    drag_operation |= ui::DragDropTypes::DRAG_COPY;
+  }
+
+  if (!sent_entered_) {
+    window_->OnDragDataCollected(screen_point, std::move(data), drag_operation);
+    sent_entered_ = true;
+  }
+  window_->OnDragMotion(screen_point, 0, position_time_stamp_, drag_operation);
+
+  // Sends an XdndStatus message back to the source_window. l[2,3]
+  // theoretically represent an area in the window where the current action is
+  // the same as what we're returning, but I can't find any implementation that
+  // actually making use of this. A client can return (0, 0) and/or set the
+  // first bit of l[1] to disable the feature, and it appears that gtk neither
+  // sets this nor respects it if set.
+  XEvent xev;
+  xev.xclient.type = ClientMessage;
+  xev.xclient.message_type = gfx::GetAtom(kXdndStatus);
+  xev.xclient.format = 32;
+  xev.xclient.window = source_window;
+  xev.xclient.data.l[0] = local_window_;
+  xev.xclient.data.l[1] =
+      (drag_operation != 0) ? (kWantFurtherPosEvents | kWillAcceptDrop) : 0;
+  xev.xclient.data.l[2] = 0;
+  xev.xclient.data.l[3] = 0;
+  xev.xclient.data.l[4] = DragOperationToAtom(drag_operation);
+
+  ui::SendXClientEvent(source_window, &xev);
+}
+
+void X11DragContext::OnXdndDrop(int drag_operation) {
+  XEvent xev;
+  xev.xclient.type = ClientMessage;
+  xev.xclient.message_type = gfx::GetAtom(kXdndFinished);
+  xev.xclient.format = 32;
+  xev.xclient.window = source_window();
+  xev.xclient.data.l[0] = local_window_;
+  xev.xclient.data.l[1] = (drag_operation != 0) ? 1 : 0;
+  xev.xclient.data.l[2] = DragOperationToAtom(drag_operation);
+
+  ui::SendXClientEvent(source_window(), &xev);
+}
+
+}  // namespace ui
diff --git a/ui/ozone/platform/x11/x11_drag_context.h b/ui/ozone/platform/x11/x11_drag_context.h
new file mode 100644
index 0000000000000..191c1beae0ae4
--- /dev/null
+++ b/ui/ozone/platform/x11/x11_drag_context.h
@@ -0,0 +1,115 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_OZONE_PLATFORM_X11_X11_DRAG_CONTEXT_H_
+#define UI_OZONE_PLATFORM_X11_X11_DRAG_CONTEXT_H_
+
+#include "ui/base/x/selection_utils.h"
+#include "ui/gfx/x/x11.h"
+#include "ui/gfx/x/x11_atom_cache.h"
+#include "ui/gfx/geometry/point_f.h"
+
+namespace ui {
+
+class XScopedEventSelector;
+class X11WindowOzone;
+
+class X11DragContext {
+ public:
+  X11DragContext(X11WindowOzone* window,
+                 XID local_window,
+                 const XClientMessageEvent& event,
+                 const SelectionFormatMap* map);
+  ~X11DragContext();
+
+  void OnXdndPosition(const XClientMessageEvent& event);
+  // When we receive an XdndPosition message, we need to have all the data
+  // copied from the other window before we process the XdndPosition
+  // message. If we have that data already, dispatch immediately. Otherwise,
+  // delay dispatching until we do.
+  void OnXdndPositionMessage(::Atom suggested_action,
+                             XID source_window,
+                             ::Time time_stamp,
+                             const gfx::PointF& screen_point);
+
+  // Called when XSelection data has been copied to our process.
+  void OnSelectionNotify(const XSelectionEvent& xselection);
+
+  void OnXdndDrop(int drag_operation);
+
+  // Clones the fetched targets.
+  const ui::SelectionFormatMap& fetched_targets() { return fetched_targets_; }
+
+  // Reads the kXdndActionList property from |source_window| and copies it
+  // into |actions|.
+  void ReadActions();
+
+  // Creates a ui::DragDropTypes::DragOperation representation of the current
+  // action list.
+  int GetDragOperation() const;
+
+  // views::DesktopDragDropClientOzone* source_client() { return source_client_; }
+
+  XID source_window() { return source_window_; }
+
+ private:
+  // Called to request the next target from the source window. This is only
+  // done on the first XdndPosition; after that, we cache the data offered by
+  // the source window.
+  void RequestNextTarget();
+
+  // Masks the X11 atom |xdnd_operation|'s views representation onto
+  // |drag_operation|.
+  void MaskOperation(::Atom xdnd_operation, int* drag_operation) const;
+
+  void CompleteXdndPosition(::Window source_window,
+                            const gfx::PointF& screen_point);
+
+  void SendXClientEvent(XID xid, XEvent* xev);
+
+  X11WindowOzone* window_;
+
+  // The XID of our chrome local aura window handling our events.
+  XID local_window_;
+
+  // The XID of the window that's initiated the drag.
+  XID source_window_;
+
+  // Events that we have selected on |source_window_|.
+  std::unique_ptr<ui::XScopedEventSelector> source_window_events_;
+
+  // Whether we're blocking the handling of an XdndPosition message by waiting
+  // for |unfetched_targets_| to be fetched.
+  bool waiting_to_handle_position_;
+
+  // Where the cursor is on screen.
+  gfx::PointF screen_point_;
+
+  // The time stamp of the last XdndPosition event we received. The XDND
+  // specification mandates that we use this time stamp when querying the source
+  // about the drag and drop data.
+  ::Time position_time_stamp_;
+
+  // A SelectionFormatMap of data that we have in our process.
+  ui::SelectionFormatMap fetched_targets_;
+
+  // The names of various data types offered by the other window that we
+  // haven't fetched and put in |fetched_targets_| yet.
+  std::vector<::Atom> unfetched_targets_;
+
+  // XdndPosition messages have a suggested action. Qt applications exclusively
+  // use this, instead of the XdndActionList which is backed by |actions_|.
+  ::Atom suggested_action_;
+
+  // Possible actions.
+  std::vector<::Atom> actions_;
+
+  bool sent_entered_ = false;
+
+  DISALLOW_COPY_AND_ASSIGN(X11DragContext);
+};
+
+}  // namespace ui
+
+#endif  // UI_OZONE_PLATFORM_X11_X11_DRAG_CONTEXT_H_
diff --git a/ui/ozone/platform/x11/x11_drag_source.cc b/ui/ozone/platform/x11/x11_drag_source.cc
new file mode 100644
index 0000000000000..c2c3d7eca545f
--- /dev/null
+++ b/ui/ozone/platform/x11/x11_drag_source.cc
@@ -0,0 +1,458 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/ozone/platform/x11/x11_drag_source.h"
+
+#include "base/threading/thread_task_runner_handle.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/base/x/x11_window_event_manager.h"
+#include "ui/events/event.h"
+#include "ui/events/event_utils.h"
+#include "ui/events/platform/scoped_event_dispatcher.h"
+#include "ui/ozone/platform/x11/x11_drag_util.h"
+#include "ui/ozone/platform/x11/x11_window_ozone.h"
+
+namespace ui {
+
+namespace {
+
+// The time to wait since sending the last XdndPosition message before
+// reprocessing the most recent mouse move event in case that the window
+// stacking order has changed and |source_current_window_| needs to be updated.
+const int kRepeatMouseMoveTimeoutMs = 350;
+
+// The time to wait for the target to respond after the user has released the
+// mouse button before ending the move loop.
+const int kEndMoveLoopTimeoutMs = 1000;
+
+XID ValidateXdndWindow(XID window) {
+  if (window == x11::None)
+    return x11::None;
+
+  // TODO(crbug/651775): The proxy window should be reported separately from the
+  //     target window. XDND messages should be sent to the proxy, and their
+  //     window field should point to the target.
+
+  // Figure out which window we should test as XdndAware. If |target| has
+  // XdndProxy, it will set that proxy on target, and if not, |target|'s
+  // original value will remain.
+  ui::GetXIDProperty(window, kXdndProxy, &window);
+
+  int version;
+  if (ui::GetIntProperty(window, kXdndAware, &version) &&
+      version >= kMaxXdndVersion) {
+    return window;
+  }
+  return x11::None;
+}
+
+}  // namespace
+
+X11DragSource::X11DragSource(X11WindowOzone* window,
+                             XID xwindow,
+                             int operation,
+                             const ui::OSExchangeData& data)
+    : window_(window),
+      xwindow_(xwindow),
+      drag_operation_(operation),
+      negotiated_operation_(ui::DragDropTypes::DRAG_NONE),
+      source_state_(SOURCE_STATE_OTHER),
+      format_map_(),
+      selection_owner_(gfx::GetXDisplay(),
+                       xwindow,
+                       gfx::GetAtom(kXdndSelection)),
+      screen_point_(gfx::Point()),
+      weak_factory_(this) {
+  XStoreName(gfx::GetXDisplay(), xwindow, "Chromium Drag & Drop Window");
+  CreateDragInputWindow(gfx::GetXDisplay());
+
+  base::string16 str;
+  const OSExchangeData::FilenameToURLPolicy policy =
+      OSExchangeData::FilenameToURLPolicy::DO_NOT_CONVERT_FILENAMES;
+  if (data.HasURL(policy)) {
+    GURL url;
+    base::string16 title;
+    data.GetURLAndTitle(policy, &url, &title);
+    InsertURLToSelectionFormatMap(url, title, &format_map_);
+  }
+  if (data.GetString(&str)) {
+    InsertStringToSelectionFormatMap(str, &format_map_);
+  }
+  selection_owner_.TakeOwnershipOfSelection(format_map_);
+
+  old_dispatcher_ = std::move(nested_dispatcher_);
+  nested_dispatcher_ =
+      ui::PlatformEventSource::GetInstance()->OverrideDispatcher(this);
+}
+
+X11DragSource::~X11DragSource() {
+  window_ = nullptr;
+  last_motion_in_screen_.reset();
+
+  if (source_current_window_ != gfx::kNullAcceleratedWidget) {
+    SendXdndLeave(source_current_window_);
+    source_current_window_ = gfx::kNullAcceleratedWidget;
+  }
+  repeat_mouse_move_timer_.Stop();
+  end_move_loop_timer_.Stop();
+
+  grab_input_window_events_.reset();
+  XDestroyWindow(gfx::GetXDisplay(), grab_input_window_);
+  grab_input_window_ = gfx::kNullAcceleratedWidget;
+
+  nested_dispatcher_ = std::move(old_dispatcher_);
+}
+
+void X11DragSource::OnXdndStatus(const XClientMessageEvent& event) {
+  DVLOG(1) << "OnXdndStatus";
+
+  gfx::AcceleratedWidget source_window = event.data.l[0];
+
+  if (source_window != source_current_window_)
+    return;
+
+  if (source_state_ != SOURCE_STATE_PENDING_DROP &&
+      source_state_ != SOURCE_STATE_OTHER) {
+    return;
+  }
+
+  waiting_on_status_ = false;
+  status_received_since_enter_ = true;
+
+  if (event.data.l[1] & 1) {
+    ::Atom atom_operation = event.data.l[4];
+    negotiated_operation_ = AtomToDragOperation(atom_operation);
+  } else {
+    negotiated_operation_ = ui::DragDropTypes::DRAG_NONE;
+  }
+
+  if (source_state_ == SOURCE_STATE_PENDING_DROP) {
+    // We were waiting on the status message so we could send the XdndDrop.
+    if (negotiated_operation_ == ui::DragDropTypes::DRAG_NONE) {
+      FinishDragDrop();
+      return;
+    }
+    source_state_ = SOURCE_STATE_DROPPED;
+    SendXdndDrop(source_window);
+    return;
+  }
+
+  ui::CursorType cursor_type = ui::CursorType::kNull;
+  switch (negotiated_operation_) {
+    case ui::DragDropTypes::DRAG_NONE:
+      cursor_type = ui::CursorType::kDndNone;
+      break;
+    case ui::DragDropTypes::DRAG_MOVE:
+      cursor_type = ui::CursorType::kDndMove;
+      break;
+    case ui::DragDropTypes::DRAG_COPY:
+      cursor_type = ui::CursorType::kDndCopy;
+      break;
+    case ui::DragDropTypes::DRAG_LINK:
+      cursor_type = ui::CursorType::kDndLink;
+      break;
+  }
+  // Note: event.data.[2,3] specify a rectangle. It is a request by the other
+  // window to not send further XdndPosition messages while the cursor is
+  // within it. However, it is considered advisory and (at least according to
+  // the spec) the other side must handle further position messages within
+  // it. GTK+ doesn't bother with this, so neither should we.
+
+  if (next_position_message_.get()) {
+    // We were waiting on the status message so we could send off the next
+    // position message we queued up.
+    gfx::Point p = next_position_message_->first;
+    unsigned long event_time = next_position_message_->second;
+    next_position_message_.reset();
+
+    SendXdndPosition(source_window, p, event_time);
+  }
+}
+
+void X11DragSource::OnXdndFinished(const XClientMessageEvent& event) {
+  gfx::AcceleratedWidget source_window = event.data.l[0];
+  if (source_current_window_ != source_window)
+    return;
+
+  // Clear |negotiated_operation_| if the drag was rejected.
+  if ((event.data.l[1] & 1) == 0)
+    negotiated_operation_ = ui::DragDropTypes::DRAG_NONE;
+
+  // Clear |source_current_window_| to avoid sending XdndLeave upon ending the
+  // move loop.
+  source_current_window_ = gfx::kNullAcceleratedWidget;
+  FinishDragDrop();
+}
+
+void X11DragSource::OnSelectionRequest(const XEvent& event) {
+  selection_owner_.OnSelectionRequest(event);
+}
+
+DragDropTypes::DragOperation X11DragSource::negotiated_operation() {
+  return negotiated_operation_;
+}
+
+bool X11DragSource::CanDispatchEvent(const ui::PlatformEvent& event) {
+  return true;
+}
+
+uint32_t X11DragSource::DispatchEvent(const ui::PlatformEvent& event) {
+  DCHECK(base::MessageLoopForUI::IsCurrent());
+
+  // This method processes all events while the move loop is active.
+  ui::EventType type = event->type();
+  switch (type) {
+    case ui::ET_MOUSE_MOVED:
+    case ui::ET_MOUSE_DRAGGED: {
+      bool dispatch_mouse_event = !last_motion_in_screen_.get();
+      last_motion_in_screen_.reset(
+          ui::EventFromNative(event).release()->AsMouseEvent());
+
+      last_motion_in_screen_->set_location(
+          ui::EventSystemLocationFromNative(event));
+      if (dispatch_mouse_event) {
+        // Post a task to dispatch mouse movement event when control returns to
+        // the message loop. This allows smoother dragging since the events are
+        // dispatched without waiting for the drag widget updates.
+        base::ThreadTaskRunnerHandle::Get()->PostTask(
+            FROM_HERE, base::Bind(&X11DragSource::DispatchMouseMovement,
+                                  weak_factory_.GetWeakPtr()));
+      }
+      return ui::POST_DISPATCH_NONE;
+    } break;
+    case ui::ET_MOUSE_RELEASED: {
+      // TODO: left button checking.
+      // Assume that drags are being done with the left mouse button. Only
+      // break the drag if the left mouse button was released.
+      DispatchMouseMovement();
+      HandleMouseRelease();
+
+      if (!grabbed_pointer_) {
+        // If the source widget had capture prior to the move loop starting,
+        // it may be relying on views::Widget getting the mouse release and
+        // releasing capture in Widget::OnMouseEvent().
+        return ui::POST_DISPATCH_PERFORM_DEFAULT;
+      }
+    } break;
+    default:
+      break;
+  }
+  return ui::POST_DISPATCH_PERFORM_DEFAULT;
+}
+
+void X11DragSource::CreateDragInputWindow(XDisplay* display) {
+  unsigned long attribute_mask = CWEventMask | CWOverrideRedirect;
+  XSetWindowAttributes swa;
+  memset(&swa, 0, sizeof(swa));
+  swa.override_redirect = x11::True;
+  grab_input_window_ = XCreateWindow(display, DefaultRootWindow(display), -100,
+                                     -100, 10, 10, 0, CopyFromParent, InputOnly,
+                                     CopyFromParent, attribute_mask, &swa);
+  uint32_t event_mask = ButtonPressMask | ButtonReleaseMask |
+                        PointerMotionMask | KeyPressMask | KeyReleaseMask |
+                        StructureNotifyMask;
+  grab_input_window_events_.reset(
+      new ui::XScopedEventSelector(grab_input_window_, event_mask));
+
+  XMapRaised(display, grab_input_window_);
+}
+
+void X11DragSource::SendXdndEnter(XID dest_window) {
+  XEvent xev;
+  xev.xclient.type = ClientMessage;
+  xev.xclient.message_type = gfx::GetAtom(kXdndEnter);
+  xev.xclient.format = 32;
+  xev.xclient.window = dest_window;
+  xev.xclient.data.l[0] = xwindow_;
+  xev.xclient.data.l[1] = (kMaxXdndVersion << 24);  // The version number.
+  xev.xclient.data.l[2] = 0;
+  xev.xclient.data.l[3] = 0;
+  xev.xclient.data.l[4] = 0;
+
+  std::vector<Atom> targets;
+  selection_owner_.RetrieveTargets(&targets);
+
+  if (targets.size() > 3) {
+    xev.xclient.data.l[1] |= 1;
+    ui::SetAtomArrayProperty(xwindow_, kXdndTypeList, "ATOM", targets);
+  } else {
+    // Pack the targets into the enter message.
+    for (size_t i = 0; i < targets.size(); ++i)
+      xev.xclient.data.l[2 + i] = targets[i];
+  }
+
+  ui::SendXClientEvent(dest_window, &xev);
+}
+
+void X11DragSource::SendXdndLeave(XID dest_window) {
+  XEvent xev;
+  xev.xclient.type = ClientMessage;
+  xev.xclient.message_type = gfx::GetAtom(kXdndLeave);
+  xev.xclient.format = 32;
+  xev.xclient.window = dest_window;
+  xev.xclient.data.l[0] = xwindow_;
+  xev.xclient.data.l[1] = 0;
+  xev.xclient.data.l[2] = 0;
+  xev.xclient.data.l[3] = 0;
+  xev.xclient.data.l[4] = 0;
+  ui::SendXClientEvent(dest_window, &xev);
+}
+
+void X11DragSource::SendXdndPosition(XID dest_window,
+                                     const gfx::Point& screen_point,
+                                     unsigned long event_time) {
+  waiting_on_status_ = true;
+
+  XEvent xev;
+  xev.xclient.type = ClientMessage;
+  xev.xclient.message_type = gfx::GetAtom(kXdndPosition);
+  xev.xclient.format = 32;
+  xev.xclient.window = dest_window;
+  xev.xclient.data.l[0] = xwindow_;
+  xev.xclient.data.l[1] = 0;
+  xev.xclient.data.l[2] = (screen_point.x() << 16) | screen_point.y();
+  xev.xclient.data.l[3] = event_time;
+  xev.xclient.data.l[4] = DragOperationToAtom(drag_operation_);
+  ui::SendXClientEvent(dest_window, &xev);
+
+  // http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html and
+  // the Xdnd protocol both recommend that drag events should be sent
+  // periodically.
+  repeat_mouse_move_timer_.Start(
+      FROM_HERE, base::TimeDelta::FromMilliseconds(kRepeatMouseMoveTimeoutMs),
+      base::Bind(&X11DragSource::ProcessMouseMove, base::Unretained(this),
+                 screen_point, event_time));
+}
+
+void X11DragSource::SendXdndDrop(XID dest_window) {
+  XEvent xev;
+  xev.xclient.type = ClientMessage;
+  xev.xclient.message_type = gfx::GetAtom(kXdndDrop);
+  xev.xclient.format = 32;
+  xev.xclient.window = dest_window;
+  xev.xclient.data.l[0] = xwindow_;
+  xev.xclient.data.l[1] = 0;
+  xev.xclient.data.l[2] = x11::CurrentTime;
+  xev.xclient.data.l[3] = x11::None;
+  xev.xclient.data.l[4] = x11::None;
+  ui::SendXClientEvent(dest_window, &xev);
+}
+
+void X11DragSource::DispatchMouseMovement() {
+  if (!last_motion_in_screen_)
+    return;
+
+  repeat_mouse_move_timer_.Stop();
+  base::TimeTicks time_stamp = last_motion_in_screen_->time_stamp();
+  ProcessMouseMove(last_motion_in_screen_->location(),
+                   (time_stamp - base::TimeTicks()).InMilliseconds());
+
+  last_motion_in_screen_.reset();
+}
+
+void X11DragSource::ProcessMouseMove(const gfx::Point& screen_point,
+                                     unsigned long event_time) {
+  if (source_state_ != SOURCE_STATE_OTHER)
+    return;
+
+  // Find the current window the cursor is over.
+  gfx::AcceleratedWidget dest_window = gfx::kNullAcceleratedWidget;
+  window_->OnMouseMoved(screen_point, &dest_window);
+  if (dest_window == gfx::kNullAcceleratedWidget) {
+    screen_point_ = screen_point;
+    ui::EnumerateTopLevelWindows(this);
+    dest_window = ValidateXdndWindow(toplevel_);
+  }
+
+  if (source_current_window_ != dest_window) {
+    if (source_current_window_ != gfx::kNullAcceleratedWidget)
+      SendXdndLeave(source_current_window_);
+
+    source_current_window_ = dest_window;
+    waiting_on_status_ = false;
+    next_position_message_.reset();
+    status_received_since_enter_ = false;
+    negotiated_operation_ = ui::DragDropTypes::DRAG_NONE;
+
+    if (source_current_window_ != gfx::kNullAcceleratedWidget)
+      SendXdndEnter(source_current_window_);
+  }
+
+  if (source_current_window_ != gfx::kNullAcceleratedWidget) {
+    if (waiting_on_status_) {
+      next_position_message_.reset(
+          new std::pair<gfx::Point, unsigned long>(screen_point, event_time));
+    } else {
+      SendXdndPosition(dest_window, screen_point, event_time);
+    }
+  }
+}
+
+void X11DragSource::StartEndMoveLoopTimer() {
+  end_move_loop_timer_.Start(
+      FROM_HERE, base::TimeDelta::FromMilliseconds(kEndMoveLoopTimeoutMs), this,
+      &X11DragSource::FinishDragDrop);
+}
+
+void X11DragSource::FinishDragDrop() {
+  window_->OnDragSessionClose(negotiated_operation_);
+}
+
+void X11DragSource::HandleMouseRelease() {
+  repeat_mouse_move_timer_.Stop();
+
+  if (source_state_ != SOURCE_STATE_OTHER) {
+    // The user has previously released the mouse and is clicking in
+    // frustration.
+    FinishDragDrop();
+    return;
+  }
+
+  if (source_current_window_ != gfx::kNullAcceleratedWidget) {
+    if (waiting_on_status_) {
+      if (status_received_since_enter_) {
+        // If we are waiting for an XdndStatus message, we need to wait for it
+        // to complete.
+        source_state_ = SOURCE_STATE_PENDING_DROP;
+
+        // Start timer to end the move loop if the target takes too long to send
+        // the XdndStatus and XdndFinished messages.
+        StartEndMoveLoopTimer();
+        return;
+      }
+
+      FinishDragDrop();
+      return;
+    }
+
+    if (negotiated_operation_ != ui::DragDropTypes::DRAG_NONE) {
+      // Start timer to end the move loop if the target takes too long to send
+      // an XdndFinished message. It is important that StartEndMoveLoopTimer()
+      // is called before SendXdndDrop() because SendXdndDrop()
+      // sends XdndFinished synchronously if the drop target is a Chrome
+      // window.
+      StartEndMoveLoopTimer();
+
+      // We have negotiated an action with the other end.
+      source_state_ = SOURCE_STATE_DROPPED;
+      SendXdndDrop(source_current_window_);
+      return;
+    }
+  }
+
+  FinishDragDrop();
+}
+
+bool X11DragSource::ShouldStopIterating(XID xid) {
+  if (!ui::IsWindowVisible(xid))
+    return false;
+
+  if (ui::WindowContainsPoint(xid, screen_point_)) {
+    toplevel_ = xid;
+    return true;
+  }
+  return false;
+}
+
+}  // namespace ui
diff --git a/ui/ozone/platform/x11/x11_drag_source.h b/ui/ozone/platform/x11/x11_drag_source.h
new file mode 100644
index 0000000000000..e1445e04361ec
--- /dev/null
+++ b/ui/ozone/platform/x11/x11_drag_source.h
@@ -0,0 +1,157 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_OZONE_PLATFORM_X11_X11_DRAG_SOURCE_H_
+#define UI_OZONE_PLATFORM_X11_X11_DRAG_SOURCE_H_
+
+#include "base/timer/timer.h"
+#include "ui/base/dragdrop/drag_drop_types.h"
+#include "ui/base/x/selection_owner.h"
+#include "ui/base/x/x11_util.h"
+#include "ui/events/platform/platform_event_dispatcher.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/native_widget_types.h"
+
+namespace ui {
+class MouseEvent;
+class ScopedEventDispatcher;
+class XScopedEventSelector;
+class X11WindowOzone;
+class OSExchangeData;
+
+class X11DragSource : public ui::PlatformEventDispatcher,
+                      public ui::EnumerateWindowsDelegate {
+ public:
+  explicit X11DragSource(X11WindowOzone* window,
+                         XID xwindow,
+                         int operation,
+                         const OSExchangeData& data);
+  ~X11DragSource() override;
+
+  void OnXdndStatus(const XClientMessageEvent& event);
+  void OnXdndFinished(const XClientMessageEvent& event);
+  void OnSelectionRequest(const XEvent& event);
+
+  DragDropTypes::DragOperation negotiated_operation();
+  SelectionFormatMap* format_map() { return &format_map_; }
+
+  // ui:::PlatformEventDispatcher:
+  bool CanDispatchEvent(const ui::PlatformEvent& event) override;
+  uint32_t DispatchEvent(const ui::PlatformEvent& event) override;
+
+ private:
+  enum SourceState {
+    // |source_current_window_| will receive a drop once we receive an
+    // XdndStatus from it.
+    SOURCE_STATE_PENDING_DROP,
+
+    // The move looped will be ended once we receive XdndFinished from
+    // |source_current_window_|. We should not send XdndPosition to
+    // |source_current_window_| while in this state.
+    SOURCE_STATE_DROPPED,
+
+    // There is no drag in progress or there is a drag in progress and the
+    // user has not yet released the mouse.
+    SOURCE_STATE_OTHER,
+  };
+
+  // Creates an input-only window to be used during the drag.
+  void CreateDragInputWindow(XDisplay* display);
+
+  void HandleMouseRelease();
+
+  void FinishDragDrop();
+
+  void SendXdndEnter(XID dest_window);
+  void SendXdndLeave(XID dest_window);
+  void SendXdndPosition(XID dest_window,
+                        const gfx::Point& screen_point,
+                        unsigned long event_time);
+  void SendXdndDrop(XID dest_window);
+
+  void ProcessMouseMove(const gfx::Point& screen_point,
+                        unsigned long event_time);
+
+  // Dispatch mouse movement event to |delegate_| in a posted task.
+  void DispatchMouseMovement();
+
+  void StartEndMoveLoopTimer();
+
+  // ui::EnumerateWindowsDelegate:
+  bool ShouldStopIterating(XID xid) override;
+
+  // An invisible InputOnly window. Keyboard grab and sometimes mouse grab
+  // are set on this window.
+  XID grab_input_window_;
+
+  // Events selected on |grab_input_window_|.
+  std::unique_ptr<ui::XScopedEventSelector> grab_input_window_events_;
+
+  // Whether the pointer was grabbed on |grab_input_window_|.
+  bool grabbed_pointer_;
+
+  X11WindowOzone* window_;
+
+  XID xwindow_;
+
+  std::unique_ptr<MouseEvent> last_motion_in_screen_;
+  gfx::AcceleratedWidget source_current_window_;
+
+  // When the mouse is released, we need to wait for the last XdndStatus message
+  // only if we have previously received a status message from
+  // |source_current_window_|.
+  bool status_received_since_enter_;
+
+  // In the Xdnd protocol, we aren't supposed to send another XdndPosition
+  // message until we have received a confirming XdndStatus message.
+  bool waiting_on_status_;
+
+  // If we would send an XdndPosition message while we're waiting for an
+  // XdndStatus response, we need to cache the latest details we'd send.
+  std::unique_ptr<std::pair<gfx::Point, unsigned long>> next_position_message_;
+
+  // The operation bitfield as requested by StartDragAndDrop.
+  int drag_operation_;
+
+  // We offer the other window a list of possible operations,
+  // XdndActionsList. This is the requested action from the other window. This
+  // is DRAG_NONE if we haven't sent out an XdndPosition message yet, haven't
+  // yet received an XdndStatus or if the other window has told us that there's
+  // no action that we can agree on.
+  DragDropTypes::DragOperation negotiated_operation_;
+
+  // Reprocesses the most recent mouse move event if the mouse has not moved
+  // in a while in case the window stacking order has changed and
+  // |source_current_window_| needs to be updated.
+  base::OneShotTimer repeat_mouse_move_timer_;
+
+  SourceState source_state_;
+
+  // Ends the move loop if the target is too slow to respond after the mouse is
+  // released.
+  base::OneShotTimer end_move_loop_timer_;
+
+  std::unique_ptr<ui::ScopedEventDispatcher> nested_dispatcher_;
+
+  std::unique_ptr<ui::ScopedEventDispatcher> old_dispatcher_;
+
+  // A representation of data. This is either passed to us from the other
+  // process, or built up through a sequence of Set*() calls. It can be passed
+  // to |selection_owner_| when we take the selection.
+  SelectionFormatMap format_map_;
+
+  // Takes a snapshot of |format_map_| and offers it to other windows.
+  mutable SelectionOwner selection_owner_;
+
+  gfx::Point screen_point_;
+  XID toplevel_;
+
+  base::WeakPtrFactory<X11DragSource> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(X11DragSource);
+};
+
+}  // namespace ui
+
+#endif  // UI_OZONE_PLATFORM_X11_X11_DRAG_SOURCE_H_
diff --git a/ui/ozone/platform/x11/x11_drag_util.cc b/ui/ozone/platform/x11/x11_drag_util.cc
new file mode 100644
index 0000000000000..62c15ab59d52c
--- /dev/null
+++ b/ui/ozone/platform/x11/x11_drag_util.cc
@@ -0,0 +1,108 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/ozone/platform/x11/x11_drag_util.h"
+
+#include "base/memory/ref_counted_memory.h"
+#include "base/strings/string_split.h"
+#include "base/strings/utf_string_conversions.h"
+#include "ui/base/x/selection_utils.h"
+
+namespace ui {
+
+namespace {
+const char kDragNetscapeURL[] = "_NETSCAPE_URL";
+const char kDragString[] = "STRING";
+const char kDragText[] = "TEXT";
+const char kDragTextPlain[] = "text/plain";
+const char kDragTextPlainUtf8[] = "text/plain;charset=utf-8";
+const char kDragUtf8String[] = "UTF8_STRING";
+}  // namespace
+
+::Atom DragOperationToAtom(int drag_operation) {
+  if (drag_operation & DragDropTypes::DRAG_COPY)
+    return gfx::GetAtom(kXdndActionCopy);
+  if (drag_operation & DragDropTypes::DRAG_MOVE)
+    return gfx::GetAtom(kXdndActionMove);
+  if (drag_operation & DragDropTypes::DRAG_LINK)
+    return gfx::GetAtom(kXdndActionLink);
+
+  return x11::None;
+}
+
+DragDropTypes::DragOperation AtomToDragOperation(::Atom atom) {
+  if (atom == gfx::GetAtom(kXdndActionCopy))
+    return DragDropTypes::DRAG_COPY;
+  if (atom == gfx::GetAtom(kXdndActionMove))
+    return DragDropTypes::DRAG_MOVE;
+  if (atom == gfx::GetAtom(kXdndActionLink))
+    return DragDropTypes::DRAG_LINK;
+
+  return DragDropTypes::DRAG_NONE;
+}
+
+std::vector<::Atom> GetOfferedDragOperations(int drag_operations) {
+  std::vector<::Atom> operations;
+  if (drag_operations & DragDropTypes::DRAG_COPY)
+    operations.push_back(gfx::GetAtom(kXdndActionCopy));
+  if (drag_operations & DragDropTypes::DRAG_MOVE)
+    operations.push_back(gfx::GetAtom(kXdndActionMove));
+  if (drag_operations & DragDropTypes::DRAG_LINK)
+    operations.push_back(gfx::GetAtom(kXdndActionLink));
+  return operations;
+}
+
+void InsertStringToSelectionFormatMap(const base::string16& text_data,
+                                      SelectionFormatMap* map) {
+  std::string utf8 = base::UTF16ToUTF8(text_data);
+  scoped_refptr<base::RefCountedMemory> mem(
+      base::RefCountedString::TakeString(&utf8));
+
+  map->Insert(gfx::GetAtom(Clipboard::kMimeTypeText), mem);
+  map->Insert(gfx::GetAtom(kDragText), mem);
+  map->Insert(gfx::GetAtom(kDragString), mem);
+  map->Insert(gfx::GetAtom(kDragUtf8String), mem);
+  map->Insert(gfx::GetAtom(kDragTextPlain), mem);
+  map->Insert(gfx::GetAtom(kDragTextPlainUtf8), mem);
+}
+
+void InsertURLToSelectionFormatMap(const GURL& url,
+                                   const base::string16& title,
+                                   SelectionFormatMap* map) {
+  if (url.is_valid()) {
+    // Mozilla's URL format: (UTF16: URL, newline, title)
+    base::string16 spec = base::UTF8ToUTF16(url.spec());
+
+    std::vector<unsigned char> data;
+    ui::AddString16ToVector(spec, &data);
+    ui::AddString16ToVector(base::ASCIIToUTF16("\n"), &data);
+    ui::AddString16ToVector(title, &data);
+    scoped_refptr<base::RefCountedMemory> mem(
+        base::RefCountedBytes::TakeVector(&data));
+
+    map->Insert(gfx::GetAtom(Clipboard::kMimeTypeMozillaURL), mem);
+
+    // Set a string fallback as well.
+    InsertStringToSelectionFormatMap(spec, map);
+
+    // Set _NETSCAPE_URL for file managers like Nautilus that use it as a hint
+    // to create a link to the URL. Setting text/uri-list doesn't work because
+    // Nautilus will fetch and copy the contents of the URL to the drop target
+    // instead of linking...
+    // Format is UTF8: URL + "\n" + title.
+    std::string netscape_url = url.spec();
+    netscape_url += "\n";
+    netscape_url += base::UTF16ToUTF8(title);
+    map->Insert(gfx::GetAtom(kDragNetscapeURL),
+                scoped_refptr<base::RefCountedMemory>(
+                    base::RefCountedString::TakeString(&netscape_url)));
+  }
+}
+
+void SendXClientEvent(XID window, XEvent* xev) {
+  DCHECK_EQ(ClientMessage, xev->type);
+  XSendEvent(gfx::GetXDisplay(), window, x11::False, 0, xev);
+}
+
+}  // namespace ui
diff --git a/ui/ozone/platform/x11/x11_drag_util.h b/ui/ozone/platform/x11/x11_drag_util.h
new file mode 100644
index 0000000000000..a7121c2a5a7fd
--- /dev/null
+++ b/ui/ozone/platform/x11/x11_drag_util.h
@@ -0,0 +1,107 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_OZONE_PLATFORM_X11_X11_DRAG_UTIL_H_
+#define UI_OZONE_PLATFORM_X11_X11_DRAG_UTIL_H_
+
+#include <vector>
+
+#include "base/strings/string_util.h"
+#include "ui/base/dragdrop/drag_drop_types.h"
+#include "ui/gfx/x/x11.h"
+#include "ui/gfx/x/x11_atom_cache.h"
+#include "url/gurl.h"
+
+namespace ui {
+
+class SelectionFormatMap;
+
+// The lowest XDND protocol version that we understand.
+//
+// The XDND protocol specification says that we must support all versions
+// between 3 and the version we advertise in the XDndAware property.
+constexpr int kMinXdndVersion = 3;
+
+// The value used in the XdndAware property.
+//
+// The XDND protocol version used between two windows will be the minimum
+// between the two versions advertised in the XDndAware property.
+constexpr int kMaxXdndVersion = 5;
+
+// Window property that contains the possible actions that will be presented to
+// the user when the drag and drop action is kXdndActionAsk.
+const char kXdndActionList[] = "XdndActionList";
+
+// Window property that tells other applications the window understands XDND.
+const char kXdndAware[] = "XdndAware";
+
+// Window property pointing to a proxy window to receive XDND target messages.
+// The XDND source must check the proxy window must for the XdndAware property,
+// and must send all XDND messages to the proxy instead of the target. However,
+// the target field in the messages must still represent the original target
+// window (the window pointed to by the cursor).
+const char kXdndProxy[] = "XdndProxy";
+
+// These actions have the same meaning as in the W3C Drag and Drop spec.
+const char kXdndActionCopy[] = "XdndActionCopy";
+const char kXdndActionMove[] = "XdndActionMove";
+const char kXdndActionLink[] = "XdndActionLink";
+
+// Message sent from an XDND source to the target to start the XDND protocol.
+// The target must wait for an XDndPosition event before querying the data.
+const char kXdndEnter[] = "XdndEnter";
+
+// Window property that holds the supported drag and drop data types.
+// This property is set on the XDND source window when the drag and drop data
+// can be converted to more than 3 types.
+const char kXdndTypeList[] = "XdndTypeList";
+
+// Message sent from an XDND source to the target when the user cancels the drag
+// and drop operation.
+const char kXdndLeave[] = "XdndLeave";
+
+// Message sent by the XDND source when the cursor position changes.
+// The source will also send an XdndPosition event right after the XdndEnter
+// event, to tell the target about the initial cursor position and the desired
+// drop action.
+// The time stamp in the XdndPosition must be used when requesting selection
+// information.
+// After the target optionally acquires selection information, it must tell the
+// source if it can accept the drop via an XdndStatus message.
+const char kXdndPosition[] = "XdndPosition";
+
+// Message sent from an XDND source to the target when the user confirms the
+// drag and drop operation.
+const char kXdndDrop[] = "XdndDrop";
+
+// Selection used by the XDND protocol to transfer data between applications.
+const char kXdndSelection[] = "XdndSelection";
+
+// Message sent by the XDND target in response to an XdndPosition message.
+// The message informs the source if the target will accept the drop, and what
+// action will be taken if the drop is accepted.
+const char kXdndStatus[] = "XdndStatus";
+
+// Message sent from an XDND target to the source in respose to an XdndDrop.
+// The message must be sent whether the target acceepts the drop or not.
+const char kXdndFinished[] = "XdndFinished";
+
+::Atom DragOperationToAtom(int drag_operation);
+
+DragDropTypes::DragOperation AtomToDragOperation(::Atom atom);
+
+std::vector<::Atom> GetOfferedDragOperations(int drag_operations);
+
+void InsertStringToSelectionFormatMap(const base::string16& text_data,
+                                      SelectionFormatMap* map);
+
+void InsertURLToSelectionFormatMap(const GURL& url,
+                                   const base::string16& title,
+                                   SelectionFormatMap* map);
+
+void SendXClientEvent(XID xwindow, XEvent* xev);
+
+}  // namespace ui
+
+#endif  // UI_OZONE_PLATFORM_X11_X11_DRAG_UTIL_H_
diff --git a/ui/ozone/platform/x11/x11_window_ozone.cc b/ui/ozone/platform/x11/x11_window_ozone.cc
index 9c312abdad9d1..80a99ababbf04 100644
--- a/ui/ozone/platform/x11/x11_window_ozone.cc
+++ b/ui/ozone/platform/x11/x11_window_ozone.cc
@@ -5,6 +5,8 @@
 #include "ui/ozone/platform/x11/x11_window_ozone.h"
 
 #include "base/bind.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/base/x/x11_util.h"
 #include "ui/events/event.h"
 #include "ui/events/event_utils.h"
 #include "ui/events/ozone/events_ozone.h"
@@ -12,6 +14,9 @@
 #include "ui/gfx/geometry/point.h"
 #include "ui/gfx/x/x11.h"
 #include "ui/ozone/platform/x11/x11_cursor_ozone.h"
+#include "ui/ozone/platform/x11/x11_drag_context.h"
+#include "ui/ozone/platform/x11/x11_drag_source.h"
+#include "ui/ozone/platform/x11/x11_drag_util.h"
 #include "ui/ozone/platform/x11/x11_window_manager_ozone.h"
 
 namespace ui {
@@ -19,7 +24,9 @@ namespace ui {
 X11WindowOzone::X11WindowOzone(X11WindowManagerOzone* window_manager,
                                PlatformWindowDelegate* delegate,
                                const gfx::Rect& bounds)
-    : X11WindowBase(delegate, bounds), window_manager_(window_manager) {
+    : X11WindowBase(delegate, bounds),
+      window_manager_(window_manager),
+      target_current_context_(nullptr) {
   DCHECK(window_manager);
   auto* event_source = X11EventSourceLibevent::GetInstance();
   if (event_source)
@@ -29,6 +36,11 @@ X11WindowOzone::X11WindowOzone(X11WindowManagerOzone* window_manager,
 #if !defined(OS_CHROMEOS)
   move_loop_client_.reset(new WindowMoveLoopClient());
 #endif
+
+  unsigned long xdnd_version = kMaxXdndVersion;
+  XChangeProperty(xdisplay(), xwindow(), gfx::GetAtom(kXdndAware), XA_ATOM, 32,
+                  PropModeReplace,
+                  reinterpret_cast<unsigned char*>(&xdnd_version), 1);
 }
 
 X11WindowOzone::~X11WindowOzone() {
@@ -54,6 +66,17 @@ void X11WindowOzone::SetCursor(PlatformCursor cursor) {
   XDefineCursor(xdisplay(), xwindow(), cursor_ozone->xcursor());
 }
 
+void X11WindowOzone::StartDrag(const ui::OSExchangeData& data,
+                               int operation,
+                               gfx::NativeCursor cursor,
+                               base::OnceCallback<void(int)> callback) {
+  std::vector<::Atom> actions = GetOfferedDragOperations(operation);
+  ui::SetAtomArrayProperty(xwindow(), kXdndActionList, "ATOM", actions);
+
+  drag_source_ =
+      std::make_unique<X11DragSource>(this, xwindow(), operation, data);
+}
+
 bool X11WindowOzone::RunMoveLoop(const gfx::Vector2d& drag_offset) {
 // TODO(msisov, tonikitoo): Add a dummy implementation for chromeos.
 #if !defined(OS_CHROMEOS)
@@ -88,6 +111,9 @@ bool X11WindowOzone::DispatchXEvent(XEvent* xev) {
   if (!IsEventForXWindow(*xev))
     return false;
 
+  if (ProcessDragDropEvent(xev))
+    return true;
+
   ProcessXWindowEvent(xev);
   return true;
 }
@@ -127,4 +153,147 @@ void X11WindowOzone::OnLostCapture() {
   delegate()->OnLostCapture();
 }
 
+void X11WindowOzone::OnDragDataCollected(const gfx::PointF& screen_point,
+                                         std::unique_ptr<OSExchangeData> data,
+                                         int operation) {
+  // TODO(jkim).
+  // delegate()->OnDragEnter(this, screen_point, std::move(data), operation);
+  NOTIMPLEMENTED_LOG_ONCE();
+}
+
+void X11WindowOzone::OnMouseMoved(const gfx::Point& point,
+                                  gfx::AcceleratedWidget* widget) {
+  // TODO(jkim).
+  // delegate()->OnMouseMoved(point, widget);
+  NOTIMPLEMENTED_LOG_ONCE();
+}
+
+void X11WindowOzone::OnDragSessionClose(int dnd_action) {
+  // TODO(jkim).
+  // drag_source_.reset();
+  // delegate()->OnDragSessionClosed(dnd_action);
+  NOTIMPLEMENTED_LOG_ONCE();
+}
+
+void X11WindowOzone::OnDragMotion(const gfx::PointF& screen_point,
+                                  int flags,
+                                  ::Time event_time,
+                                  int operation) {
+  // TODO(jkim).
+  // gfx::AcceleratedWidget widget = gfx::kNullAcceleratedWidget;
+  // drag_operation_ =
+  //    delegate()->OnDragMotion(screen_point, event_time, operation, &widget);
+  NOTIMPLEMENTED_LOG_ONCE();
+}
+
+bool X11WindowOzone::ProcessDragDropEvent(XEvent* xev) {
+  switch (xev->type) {
+    case SelectionNotify: {
+      if (!target_current_context_.get()) {
+        NOTREACHED();
+        return false;
+      }
+      target_current_context_->OnSelectionNotify(xev->xselection);
+      return true;
+    }
+    case PropertyNotify: {
+      if (xev->xproperty.atom != gfx::GetAtom(kXdndActionList))
+        return false;
+      if (!target_current_context_.get() ||
+          target_current_context_->source_window() != xev->xany.window) {
+        return false;
+      }
+      target_current_context_->ReadActions();
+      return true;
+    }
+    case SelectionRequest: {
+      if (!drag_source_)
+        return false;
+      drag_source_->OnSelectionRequest(*xev);
+      return true;
+    }
+    case ClientMessage: {
+      XClientMessageEvent& event = xev->xclient;
+      Atom message_type = event.message_type;
+      if (message_type == gfx::GetAtom("WM_PROTOCOLS"))
+        return false;
+
+      if (message_type == gfx::GetAtom(kXdndEnter)) {
+        int version = (event.data.l[1] & 0xff000000) >> 24;
+        if (version < kMinXdndVersion) {
+          // This protocol version is not documented in the XDND standard (last
+          // revised in 1999), so we don't support it. Since don't understand
+          // the protocol spoken by the source, we can't tell it that we can't
+          // talk to it.
+          LOG(ERROR)
+              << "XdndEnter message discarded because its version is too old.";
+          return false;
+        }
+        if (version > kMaxXdndVersion) {
+          // The XDND version used should be the minimum between the versions
+          // advertised by the source and the target. We advertise
+          // kMaxXdndVersion, so this should never happen when talking to an
+          // XDND-compliant application.
+          LOG(ERROR)
+              << "XdndEnter message discarded because its version is too new.";
+          return false;
+        }
+        // Make sure that we've run ~X11DragContext() before creating another
+        // one.
+        target_current_context_.reset();
+        SelectionFormatMap* map = nullptr;
+        if (drag_source_)
+          map = drag_source_->format_map();
+        target_current_context_.reset(
+            new X11DragContext(this, xwindow(), event, map));
+        return true;
+      }
+      if (message_type == gfx::GetAtom(kXdndLeave)) {
+        // TODO(jkim).
+        // delegate()->OnDragLeave();
+        NOTIMPLEMENTED_LOG_ONCE();
+        return true;
+      }
+      if (message_type == gfx::GetAtom(kXdndPosition)) {
+        if (!target_current_context_.get()) {
+          NOTREACHED();
+          return false;
+        }
+
+        target_current_context_->OnXdndPosition(event);
+        return true;
+      }
+      if (message_type == gfx::GetAtom(kXdndStatus)) {
+        drag_source_->OnXdndStatus(event);
+        return true;
+      }
+      if (message_type == gfx::GetAtom(kXdndFinished)) {
+        // TODO(jkim).
+        // int negotiated_operation = drag_source_->negotiated_operation();
+        // drag_source_->OnXdndFinished(event);
+        // delegate()->OnDragSessionClosed(negotiated_operation);
+        NOTIMPLEMENTED_LOG_ONCE();
+        return true;
+      }
+      if (message_type == gfx::GetAtom(kXdndDrop)) {
+        // TODO(jkim).
+        // delegate()->OnDragDrop(nullptr);
+        return false;
+
+        if (!target_current_context_.get()) {
+          NOTREACHED();
+          return false;
+        }
+        target_current_context_->OnXdndDrop(drag_operation_);
+        target_current_context_.reset();
+        return true;
+      }
+      break;
+    }
+    default:
+      break;
+  }
+  return false;
+}
+
 }  // namespace ui
diff --git a/ui/ozone/platform/x11/x11_window_ozone.h b/ui/ozone/platform/x11/x11_window_ozone.h
index 6be3f747549df..29876f91bc2f3 100644
--- a/ui/ozone/platform/x11/x11_window_ozone.h
+++ b/ui/ozone/platform/x11/x11_window_ozone.h
@@ -13,6 +13,9 @@
 
 namespace ui {
 
+class OSExchangeData;
+class X11DragContext;
+class X11DragSource;
 class X11WindowManagerOzone;
 
 // PlatformWindow implementation for X11 Ozone. PlatformEvents are ui::Events.
@@ -34,6 +37,11 @@ class X11WindowOzone : public X11WindowBase,
 
   void ReleaseCapture() override;
   void SetCursor(PlatformCursor cursor) override;
+  void StartDrag(const ui::OSExchangeData& data,
+                 int operation,
+                 gfx::NativeCursor cursor,
+                 base::OnceCallback<void(int)> callback) override;
+
   bool RunMoveLoop(const gfx::Vector2d& drag_offset) override;
   void StopMoveLoop() override;
 
@@ -43,10 +51,35 @@ class X11WindowOzone : public X11WindowBase,
   PlatformEventDispatcher* GetPlatformEventDispatcher() override;
   bool DispatchXEvent(XEvent* event) override;
 
+  void OnDragDataCollected(const gfx::PointF& screen_point,
+                           std::unique_ptr<OSExchangeData> data,
+                           int operation);
+  void OnDragMotion(const gfx::PointF& screen_point,
+                    int flags,
+                    ::Time event_time,
+                    int operation);
+  void OnMouseMoved(const gfx::Point& point, gfx::AcceleratedWidget* widget);
+  void OnDragSessionClose(int dnd_action);
+
  private:
+  enum SourceState {
+    // |source_current_window_| will receive a drop once we receive an
+    // XdndStatus from it.
+    SOURCE_STATE_PENDING_DROP,
+
+    // The move looped will be ended once we receive XdndFinished from
+    // |source_current_window_|. We should not send XdndPosition to
+    // |source_current_window_| while in this state.
+    SOURCE_STATE_DROPPED,
+
+    // There is no drag in progress or there is a drag in progress and the
+    // user has not yet released the mouse.
+    SOURCE_STATE_OTHER,
+  };
   // PlatformEventDispatcher:
   bool CanDispatchEvent(const PlatformEvent& event) override;
   uint32_t DispatchEvent(const PlatformEvent& event) override;
+  bool ProcessDragDropEvent(XEvent* xev);
 
   X11WindowManagerOzone* window_manager_;
 
@@ -59,6 +92,11 @@ class X11WindowOzone : public X11WindowBase,
   // previous check in ::CheckCanDispatchNextPlatformEvent based on a XID
   // target.
   bool handle_next_event_ = false;
+  std::unique_ptr<X11DragContext> target_current_context_;
+  // DesktopDragDropClientOzone* drag_drop_client_;
+  int drag_operation_;
+  // unsigned long source_window_;
+  std::unique_ptr<X11DragSource> drag_source_;
 
   DISALLOW_COPY_AND_ASSIGN(X11WindowOzone);
 };
diff --git a/ui/platform_window/x11/x11_window_base.cc b/ui/platform_window/x11/x11_window_base.cc
index 1887b3b377a8a..fadfb00a476f2 100644
--- a/ui/platform_window/x11/x11_window_base.cc
+++ b/ui/platform_window/x11/x11_window_base.cc
@@ -354,6 +354,16 @@ bool X11WindowBase::RunMoveLoop(const gfx::Vector2d& drag_offset) {
 
 void X11WindowBase::StopMoveLoop() {}
 
+void X11WindowBase::StartDrag(const ui::OSExchangeData& data,
+                              int operation,
+                              gfx::NativeCursor cursor,
+                              base::OnceCallback<void(int)> callback) {
+  // If this is for ozone/X11, the child class of this, X11WindowOzone, will
+  // handle it. Otherwise, DragDrop has been implemented directly, for instance
+  // DesktopDragDropClientAuraX11 or DragDropControllerMus.
+  NOTREACHED();
+}
+
 void X11WindowBase::UnConfineCursor() {
   if (!has_pointer_barriers_)
     return;
diff --git a/ui/platform_window/x11/x11_window_base.h b/ui/platform_window/x11/x11_window_base.h
index 83a0c668186b8..92032f6f6818d 100644
--- a/ui/platform_window/x11/x11_window_base.h
+++ b/ui/platform_window/x11/x11_window_base.h
@@ -11,12 +11,14 @@
 
 #include "base/callback.h"
 #include "base/containers/flat_set.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
 #include "base/macros.h"
 #include "ui/gfx/geometry/rect.h"
 #include "ui/gfx/x/x11.h"
 #include "ui/gfx/x/x11_types.h"
 #include "ui/platform_window/platform_window.h"
 #include "ui/platform_window/platform_window_delegate.h"
+#include "ui/platform_window/platform_window_handler/wm_drag_handler.h"
 #include "ui/platform_window/x11/x11_window_export.h"
 
 namespace ui {
@@ -25,11 +27,18 @@ class XScopedEventSelector;
 
 // Abstract base implementation for a X11 based PlatformWindow. Methods that
 // are platform specific are left unimplemented.
-class X11_WINDOW_EXPORT X11WindowBase : public PlatformWindow {
+class X11_WINDOW_EXPORT X11WindowBase : public PlatformWindow,
+                                        public WmDragHandler {
  public:
   X11WindowBase(PlatformWindowDelegate* delegate, const gfx::Rect& bounds);
   ~X11WindowBase() override;
 
+  // Initiates Drag Action.
+  void StartDrag(const ui::OSExchangeData& data,
+                 int operation,
+                 gfx::NativeCursor cursor,
+                 base::OnceCallback<void(int)> callback) override;
+
   // PlatformWindow:
   void Show() override;
   void Hide() override;
