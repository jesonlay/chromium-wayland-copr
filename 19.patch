From 566775423c43ef3605373ddb7b17738bf48b8948 Mon Sep 17 00:00:00 2001
From: Maksim Sisov <msisov@igalia.com>
Date: Mon, 25 Feb 2019 07:34:47 +0000
Subject: [PATCH] [ozone/wayland] Fix crash when there is no zwp_linux_dmabuf

This fixes the case when zwp_linux_dmabuf interface is not available.

The fix is to make WaylandConnectionProxy to reset gbm_device, and
return nullptr instead. This makes the WaylandSurfaceFactory return
nullptr for SurfacelessViewGLSurface, which results in a software
rendering path usage when the "--in-process-gpu" flag is not
passed and ViewGLSurface, when the flag is passed.

TL;DR:

This change results in the following changes in two different cases:
  1) in-process-gpu is passed: in that mode, WaylandSurfaceFactory
tries to create surfaceless gl surface, which uses gbm and linux dmabuf
interface to create buffers. If neither gbm nor the interface are available,
surfaceless gl surface can't be created and nullptr is returned. Then,
Chromium asks to create ViewGlSurface, which uses wl_egl_surface.
  2) the flag is not passed: in that mode, the factory creates the
above mentioned surfaceless gl surface, which uses gbm and linux dmabuf
interface. If those are not available, nullptr is returned and chromium
falls back to software rendering (please note that it's impossible to create
wl_egl_surface, because it requires accessing wl_surface on the browser
process side). Note, software rendering CL is under review at
crrev.com/c/1454623

Bug: 932098
Change-Id: I95f88018ded48e7a18864f957137c2b478e788ac
Reviewed-on: https://chromium-review.googlesource.com/c/1477591
Reviewed-by: Dominick Ng <dominickn@chromium.org>
Reviewed-by: Robert Kroeger <rjkroege@chromium.org>
Commit-Queue: Maksim Sisov <msisov@igalia.com>
Cr-Commit-Position: refs/heads/master@{#635044}
---
 .../platform/wayland/gpu/wayland_connection_proxy.cc   |  8 ++++++++
 .../platform/wayland/gpu/wayland_connection_proxy.h    |  1 +
 ui/ozone/platform/wayland/ozone_platform_wayland.cc    |  2 +-
 .../wayland/wayland_buffer_manager_unittest.cc         |  4 ++--
 ui/ozone/platform/wayland/wayland_connection.cc        |  6 ++++++
 ui/ozone/platform/wayland/wayland_connection.h         |  5 ++---
 .../platform/wayland/wayland_connection_connector.cc   |  7 +++++++
 .../public/interfaces/wayland/wayland_connection.mojom | 10 ++++++++--
 8 files changed, 35 insertions(+), 8 deletions(-)

diff --git a/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.cc b/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.cc
index 9126a67c30ebc..73188f4a4fe9f 100644
--- a/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.cc
+++ b/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.cc
@@ -25,6 +25,14 @@ void WaylandConnectionProxy::SetWaylandConnection(
   wc_ptr_info_ = wc_ptr.PassInterface();
 }
 
+void WaylandConnectionProxy::ResetGbmDevice() {
+#if defined(WAYLAND_GBM)
+  gbm_device_.reset();
+#else
+  NOTREACHED();
+#endif
+}
+
 void WaylandConnectionProxy::CreateZwpLinuxDmabuf(
     base::File file,
     gfx::Size size,
diff --git a/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.h b/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.h
index 7c3d0725e5f42..2f3072cbdca9d 100644
--- a/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.h
+++ b/ui/ozone/platform/wayland/gpu/wayland_connection_proxy.h
@@ -44,6 +44,7 @@ class WaylandConnectionProxy : public ozone::mojom::WaylandConnectionClient {
 
   // WaylandConnectionProxy overrides:
   void SetWaylandConnection(ozone::mojom::WaylandConnectionPtr wc_ptr) override;
+  void ResetGbmDevice() override;
 
   // Methods, which must be used when GPU is hosted on a different process
   // aka gpu process.
diff --git a/ui/ozone/platform/wayland/ozone_platform_wayland.cc b/ui/ozone/platform/wayland/ozone_platform_wayland.cc
index 38b69e7ce0240..6bdd7919839d3 100644
--- a/ui/ozone/platform/wayland/ozone_platform_wayland.cc
+++ b/ui/ozone/platform/wayland/ozone_platform_wayland.cc
@@ -169,6 +169,7 @@ class OzonePlatformWayland : public OzonePlatform {
 
   void InitializeGPU(const InitParams& args) override {
     proxy_.reset(new WaylandConnectionProxy(connection_.get()));
+    surface_factory_.reset(new WaylandSurfaceFactory(proxy_.get()));
 #if defined(WAYLAND_GBM)
     const base::FilePath drm_node_path = path_finder_.GetDrmRenderNodePath();
     if (drm_node_path.empty()) {
@@ -185,7 +186,6 @@ class OzonePlatformWayland : public OzonePlatform {
       }
     }
 #endif
-    surface_factory_.reset(new WaylandSurfaceFactory(proxy_.get()));
   }
 
   const PlatformProperties& GetPlatformProperties() override {
diff --git a/ui/ozone/platform/wayland/wayland_buffer_manager_unittest.cc b/ui/ozone/platform/wayland/wayland_buffer_manager_unittest.cc
index 189fe8063ab77..98af9ffb35e68 100644
--- a/ui/ozone/platform/wayland/wayland_buffer_manager_unittest.cc
+++ b/ui/ozone/platform/wayland/wayland_buffer_manager_unittest.cc
@@ -98,7 +98,7 @@ TEST_P(WaylandBufferManagerTest, ValidateDataFromGpu) {
        kExistingBufferId},
   };
 
-  WaylandBufferManager* manager = connection_->buffer_manager_for_tests();
+  WaylandBufferManager* manager = connection_->buffer_manager();
   ASSERT_TRUE(manager);
 
   auto temp_file = MakeTempFile();
@@ -119,7 +119,7 @@ TEST_P(WaylandBufferManagerTest, ValidateDataFromGpu) {
 }
 
 TEST_P(WaylandBufferManagerTest, CreateAndDestroyBuffer) {
-  WaylandBufferManager* manager = connection_->buffer_manager_for_tests();
+  WaylandBufferManager* manager = connection_->buffer_manager();
   ASSERT_TRUE(manager);
 
   const uint32_t kBufferId1 = 1;
diff --git a/ui/ozone/platform/wayland/wayland_connection.cc b/ui/ozone/platform/wayland/wayland_connection.cc
index 9cf54b61898ea..f25e9960941ac 100644
--- a/ui/ozone/platform/wayland/wayland_connection.cc
+++ b/ui/ozone/platform/wayland/wayland_connection.cc
@@ -195,6 +195,8 @@ void WaylandConnection::CreateZwpLinuxDmabuf(
     uint32_t planes_count,
     uint32_t buffer_id) {
   DCHECK(base::MessageLoopCurrentForUI::IsSet());
+
+  DCHECK(buffer_manager_);
   if (!buffer_manager_->CreateBuffer(std::move(file), width, height, strides,
                                      offsets, format, modifiers, planes_count,
                                      buffer_id)) {
@@ -204,6 +206,8 @@ void WaylandConnection::CreateZwpLinuxDmabuf(
 
 void WaylandConnection::DestroyZwpLinuxDmabuf(uint32_t buffer_id) {
   DCHECK(base::MessageLoopCurrentForUI::IsSet());
+
+  DCHECK(buffer_manager_);
   if (!buffer_manager_->DestroyBuffer(buffer_id)) {
     TerminateGpuProcess(buffer_manager_->error_message());
   }
@@ -215,6 +219,8 @@ void WaylandConnection::ScheduleBufferSwap(
     const gfx::Rect& damage_region,
     ScheduleBufferSwapCallback callback) {
   DCHECK(base::MessageLoopCurrentForUI::IsSet());
+
+  CHECK(buffer_manager_);
   if (!buffer_manager_->ScheduleBufferSwap(widget, buffer_id, damage_region,
                                            std::move(callback))) {
     TerminateGpuProcess(buffer_manager_->error_message());
diff --git a/ui/ozone/platform/wayland/wayland_connection.h b/ui/ozone/platform/wayland/wayland_connection.h
index 59948b75dbf26..c5ded050c6fe1 100644
--- a/ui/ozone/platform/wayland/wayland_connection.h
+++ b/ui/ozone/platform/wayland/wayland_connection.h
@@ -82,9 +82,6 @@ class WaylandConnection : public PlatformEventSource,
   zwp_text_input_manager_v1* text_input_manager_v1() {
     return text_input_manager_v1_.get();
   }
-  WaylandBufferManager* buffer_manager_for_tests() {
-    return buffer_manager_.get();
-  }
 
   WaylandWindow* GetWindow(gfx::AcceleratedWidget widget);
   WaylandWindow* GetWindowWithLargestBounds();
@@ -115,6 +112,8 @@ class WaylandConnection : public PlatformEventSource,
     return wayland_cursor_position_.get();
   }
 
+  WaylandBufferManager* buffer_manager() const { return buffer_manager_.get(); }
+
   // Clipboard implementation.
   PlatformClipboard* GetPlatformClipboard();
   void DataSourceCancelled();
diff --git a/ui/ozone/platform/wayland/wayland_connection_connector.cc b/ui/ozone/platform/wayland/wayland_connection_connector.cc
index 9f949abf5b927..5cd3b92233adf 100644
--- a/ui/ozone/platform/wayland/wayland_connection_connector.cc
+++ b/ui/ozone/platform/wayland/wayland_connection_connector.cc
@@ -83,6 +83,13 @@ void WaylandConnectionConnector::OnWaylandConnectionPtrBinded(
   auto request = mojo::MakeRequest(&wcp_ptr);
   BindInterfaceInGpuProcess(std::move(request), binder_);
   wcp_ptr->SetWaylandConnection(std::move(wc_ptr));
+
+#if defined(WAYLAND_GBM)
+  if (!connection_->buffer_manager()) {
+    LOG(WARNING) << "zwp_linux_dmabuf is not available.";
+    wcp_ptr->ResetGbmDevice();
+  }
+#endif
 }
 
 void WaylandConnectionConnector::OnTerminateGpuProcess(std::string message) {
diff --git a/ui/ozone/public/interfaces/wayland/wayland_connection.mojom b/ui/ozone/public/interfaces/wayland/wayland_connection.mojom
index a3993ccb15c06..b13007339e9f2 100644
--- a/ui/ozone/public/interfaces/wayland/wayland_connection.mojom
+++ b/ui/ozone/public/interfaces/wayland/wayland_connection.mojom
@@ -35,8 +35,14 @@ interface WaylandConnection {
           gfx.mojom.PresentationFeedback feedback);
 };
 
-// Used by the browser process to provide the GPU process with a mojo ptr to a
-// WaylandConnection, which lives on the browser process.
+
 interface WaylandConnectionClient {
+  // Used by the browser process to provide the GPU process with a mojo ptr to a
+  // WaylandConnection, which lives on the browser process.
   SetWaylandConnection(WaylandConnection wc_ptr);
+
+  // The browser process may request the client to reset gbm device instance to
+  // avoid using zwp_linux_dmabuf protocol, which means using wl_egl_surface in
+  // a single process mode, and software rendering in a multiple process mode.
+  ResetGbmDevice();
 };
