From e1f01e63ae8fb2fb4c5321891a5d6c71f86cce2e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marcin=20Wi=C4=85cek?= <marcin@mwiacek.com>
Date: Mon, 25 Feb 2019 07:39:08 +0000
Subject: [PATCH] Improve @IntDef inside Browser
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This patch is aligning various @IntDef to some standard used with many other CLs:

1. @IntDef is first, @Retention second and related @interface third
2. there is used @Retention(RetentionPolicy.SOURCE)
3. @IntDef entries are inside @interface

BUG=919666

Change-Id: I64f57cbcb0aea7fe0652464edc088dad03e971ff
Reviewed-on: https://chromium-review.googlesource.com/c/1480451
Reviewed-by: Jinsuk Kim <jinsukkim@chromium.org>
Commit-Queue: Marcin WiÄ…cek <marcin@mwiacek.com>
Cr-Commit-Position: refs/heads/master@{#635045}
---
 .../browser/BrowserStartupControllerImpl.java | 31 ++++++++++---------
 .../browser/ServicificationStartupUma.java    |  9 +++---
 2 files changed, 20 insertions(+), 20 deletions(-)

diff --git a/content/public/android/java/src/org/chromium/content/browser/BrowserStartupControllerImpl.java b/content/public/android/java/src/org/chromium/content/browser/BrowserStartupControllerImpl.java
index fc024927eda38..50e74eb76d239 100644
--- a/content/public/android/java/src/org/chromium/content/browser/BrowserStartupControllerImpl.java
+++ b/content/public/android/java/src/org/chromium/content/browser/BrowserStartupControllerImpl.java
@@ -45,11 +45,12 @@
     @VisibleForTesting
     static final int STARTUP_FAILURE = 1;
 
-    @IntDef({BROWSER_START_TYPE_FULL_BROWSER, BROWSER_START_TYPE_SERVICE_MANAGER_ONLY})
+    @IntDef({BrowserStartType.FULL_BROWSER, BrowserStartType.SERVICE_MANAGER_ONLY})
     @Retention(RetentionPolicy.SOURCE)
-    public @interface BrowserStartType {}
-    private static final int BROWSER_START_TYPE_FULL_BROWSER = 0;
-    private static final int BROWSER_START_TYPE_SERVICE_MANAGER_ONLY = 1;
+    public @interface BrowserStartType {
+        int FULL_BROWSER = 0;
+        int SERVICE_MANAGER_ONLY = 1;
+    }
 
     private static BrowserStartupControllerImpl sInstance;
 
@@ -114,7 +115,7 @@ static boolean shouldStartGpuProcessOnBrowserStartup() {
     // once the browser is fully started, or when the ServiceManager is started and there is no
     // outstanding requests to start the full browser.
     @BrowserStartType
-    private int mCurrentBrowserStartType = BROWSER_START_TYPE_FULL_BROWSER;
+    private int mCurrentBrowserStartType = BrowserStartType.FULL_BROWSER;
 
     // If the app is only started with the ServiceManager, whether it needs to launch full browser
     // funcionalities now.
@@ -202,7 +203,7 @@ public void startBrowserProcessesAsync(boolean startGpuProcess, boolean startSer
         // If the browser process is launched with ServiceManager only, we need to relaunch the full
         // process in serviceManagerStarted() if such a request was received.
         mLaunchFullBrowserAfterServiceManagerStart |=
-                (mCurrentBrowserStartType == BROWSER_START_TYPE_SERVICE_MANAGER_ONLY)
+                (mCurrentBrowserStartType == BrowserStartType.SERVICE_MANAGER_ONLY)
                 && !startServiceManagerOnly;
         if (!mHasStartedInitializingBrowserProcess) {
             // This is the first time we have been asked to start the browser process. We set the
@@ -217,8 +218,8 @@ public void run() {
                     ThreadUtils.assertOnUiThread();
                     if (mHasCalledContentStart) return;
                     mCurrentBrowserStartType = startServiceManagerOnly
-                            ? BROWSER_START_TYPE_SERVICE_MANAGER_ONLY
-                            : BROWSER_START_TYPE_FULL_BROWSER;
+                            ? BrowserStartType.SERVICE_MANAGER_ONLY
+                            : BrowserStartType.FULL_BROWSER;
                     if (contentStart() > 0) {
                         // Failed. The callbacks may not have run, so run them.
                         enqueueCallbackExecution(STARTUP_FAILURE);
@@ -228,7 +229,7 @@ public void run() {
         } else if (mServiceManagerStarted && mLaunchFullBrowserAfterServiceManagerStart) {
             // If we missed the serviceManagerStarted() call, launch the full browser now if needed.
             // Otherwise, serviceManagerStarted() will handle the full browser launch.
-            mCurrentBrowserStartType = BROWSER_START_TYPE_FULL_BROWSER;
+            mCurrentBrowserStartType = BrowserStartType.FULL_BROWSER;
             if (contentStart() > 0) enqueueCallbackExecution(STARTUP_FAILURE);
         }
     }
@@ -247,14 +248,14 @@ public void startBrowserProcessesSync(boolean singleProcess) throws ProcessInitE
 
             boolean startedSuccessfully = true;
             if (!mHasCalledContentStart) {
-                mCurrentBrowserStartType = BROWSER_START_TYPE_FULL_BROWSER;
+                mCurrentBrowserStartType = BrowserStartType.FULL_BROWSER;
                 if (contentStart() > 0) {
                     // Failed. The callbacks may not have run, so run them.
                     enqueueCallbackExecution(STARTUP_FAILURE);
                     startedSuccessfully = false;
                 }
-            } else if (mCurrentBrowserStartType == BROWSER_START_TYPE_SERVICE_MANAGER_ONLY) {
-                mCurrentBrowserStartType = BROWSER_START_TYPE_FULL_BROWSER;
+            } else if (mCurrentBrowserStartType == BrowserStartType.SERVICE_MANAGER_ONLY) {
+                mCurrentBrowserStartType = BrowserStartType.FULL_BROWSER;
                 if (contentStart() > 0) {
                     enqueueCallbackExecution(STARTUP_FAILURE);
                     startedSuccessfully = false;
@@ -277,7 +278,7 @@ public void startBrowserProcessesSync(boolean singleProcess) throws ProcessInitE
      */
     int contentStart() {
         boolean startServiceManagerOnly =
-                mCurrentBrowserStartType == BROWSER_START_TYPE_SERVICE_MANAGER_ONLY;
+                mCurrentBrowserStartType == BrowserStartType.SERVICE_MANAGER_ONLY;
         int result = contentMainStart(startServiceManagerOnly);
         mHasCalledContentStart = true;
         // No need to launch the full browser again if we are launching full browser now.
@@ -322,12 +323,12 @@ private void serviceManagerStarted() {
         if (mLaunchFullBrowserAfterServiceManagerStart) {
             // If startFullBrowser() fails, execute the callbacks right away. Otherwise,
             // callbacks will be deferred until browser startup completes.
-            mCurrentBrowserStartType = BROWSER_START_TYPE_FULL_BROWSER;
+            mCurrentBrowserStartType = BrowserStartType.FULL_BROWSER;
             if (contentStart() > 0) enqueueCallbackExecution(STARTUP_FAILURE);
             return;
         }
 
-        if (mCurrentBrowserStartType == BROWSER_START_TYPE_SERVICE_MANAGER_ONLY) {
+        if (mCurrentBrowserStartType == BrowserStartType.SERVICE_MANAGER_ONLY) {
             executeServiceManagerCallbacks(STARTUP_SUCCESS);
         }
         recordStartupUma();
diff --git a/content/public/android/java/src/org/chromium/content/browser/ServicificationStartupUma.java b/content/public/android/java/src/org/chromium/content/browser/ServicificationStartupUma.java
index a11fcc4487486..ee573f4331c81 100644
--- a/content/public/android/java/src/org/chromium/content/browser/ServicificationStartupUma.java
+++ b/content/public/android/java/src/org/chromium/content/browser/ServicificationStartupUma.java
@@ -20,7 +20,6 @@
     @IntDef({ServicificationStartup.CHROME_COLD, ServicificationStartup.CHROME_HALF_WARM,
             ServicificationStartup.SERVICE_MANAGER_COLD,
             ServicificationStartup.SERVICE_MANAGER_WARM})
-
     @Retention(RetentionPolicy.SOURCE)
     public @interface ServicificationStartup {
         // Cold start of Chrome as a full browser.
@@ -32,11 +31,11 @@
         // Warm start of only ServiceManager when the ServiceManager is already running.
         int SERVICE_MANAGER_WARM = 3;
 
-        int COUNT = 4;
+        int NUM_ENTRIES = 4;
     }
 
     // Caches the pending commits before the native is initialized.
-    private int[] mPendingCommits = new int[ServicificationStartup.COUNT];
+    private int[] mPendingCommits = new int[ServicificationStartup.NUM_ENTRIES];
     private boolean mIsNativeInitialized;
 
     private final static ServicificationStartupUma sInstance = new ServicificationStartupUma();
@@ -93,7 +92,7 @@ public void record(@ServicificationStartup int startupMode) {
     public void commit() {
         mIsNativeInitialized = true;
 
-        for (int i = 0; i < ServicificationStartup.COUNT; i++) {
+        for (int i = 0; i < ServicificationStartup.NUM_ENTRIES; i++) {
             if (mPendingCommits[i] > 0) {
                 for (int count = 0; count < mPendingCommits[i]; count++) {
                     recordStartupMode(i);
@@ -109,6 +108,6 @@ private ServicificationStartupUma() {
 
     private void recordStartupMode(@ServicificationStartup int startupMode) {
         RecordHistogram.recordEnumeratedHistogram(
-                "Servicification.Startup", startupMode, ServicificationStartup.COUNT);
+                "Servicification.Startup", startupMode, ServicificationStartup.NUM_ENTRIES);
     }
 }
