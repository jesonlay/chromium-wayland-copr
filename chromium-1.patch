diff --git a/ui/ozone/common/linux/gbm_wrapper.cc b/ui/ozone/common/linux/gbm_wrapper.cc
index 15efd7bfeb326..2705f9b1cbf69 100644
--- a/ui/ozone/common/linux/gbm_wrapper.cc
+++ b/ui/ozone/common/linux/gbm_wrapper.cc
@@ -4,7 +4,9 @@
 
 #include "ui/ozone/common/linux/gbm_wrapper.h"
 
+#include <fcntl.h>
 #include <gbm.h>
+#include <xf86drm.h>
 
 #include "base/posix/eintr_wrapper.h"
 #include "third_party/skia/include/core/SkSurface.h"
@@ -21,6 +23,78 @@ namespace {
 #define GBM_BO_IMPORT_FD_PLANAR_5504 0x5504
 #define GBM_BO_IMPORT_FD_PLANAR_5505 0x5505
 
+// Minigbm and system linux gbm have some differences. There is no clear way how
+// to distinguish linux gbm (Mesa, basically) and minigbm, which can be both
+// third_party and minigbm. Thus, use GBM_BO_IMPORT_FD_PLANAR define to
+// identify, which gbm is used.
+#if defined(GBM_BO_IMPORT_FD_PLANAR)
+// There are some methods, which require knowing whether minigbm is used or not.
+#ifndef USING_MINIGBM
+#define USING_MINIGBM
+#endif  // USING_MINIGBM
+// Minigbm and system linux gbm have alike gbm_bo_import* structures, but some
+// of the data variables have different type.
+using gbm_bo_import_fd_data_with_modifier = struct gbm_import_fd_planar_data;
+#else
+using gbm_bo_import_fd_data_with_modifier = struct gbm_import_fd_modifier_data;
+#endif
+
+void InitializeImportData(uint32_t format,
+                          const gfx::Size& size,
+                          const std::vector<base::ScopedFD>& fds,
+                          const std::vector<gfx::NativePixmapPlane>& planes,
+                          gbm_bo_import_fd_data_with_modifier* fd_data) {
+  fd_data->width = size.width();
+  fd_data->height = size.height();
+  fd_data->format = format;
+
+  DCHECK_LE(planes.size(), 3u);
+  for (size_t i = 0; i < planes.size(); ++i) {
+    fd_data->fds[i] = fds[i < fds.size() ? i : 0].get();
+    fd_data->strides[i] = planes[i].stride;
+    fd_data->offsets[i] = planes[i].offset;
+#if defined(USING_MINIGBM)
+    fd_data->format_modifiers[i] = planes[i].modifier;
+#else
+    fd_data->modifier = planes[i].modifier;
+#endif
+  }
+}
+
+int GetPlaneFdForBo(gbm_bo* bo, size_t plane) {
+  DCHECK(plane < gbm_bo_get_plane_count(bo));
+
+  // System linux gbm (or Mesa gbm) does not provide fds per plane basis. Thus,
+  // get plane handle and use drm ioctl to get a prime fd out of it avoid having
+  // two different branches for minigbm and Mesa gbm here.
+  gbm_device* gbm_dev = gbm_bo_get_device(bo);
+  int dev_fd = gbm_device_get_fd(gbm_dev);
+  if (dev_fd <= 0) {
+    LOG(ERROR) << "Unable to get device fd";
+    return -1;
+  }
+
+  const uint32_t plane_handle = gbm_bo_get_handle_for_plane(bo, plane).u32;
+  int fd = -1;
+  int ret;
+  // Use DRM_RDWR to allow the fd to be mappable in another process.
+  ret = drmPrimeHandleToFD(dev_fd, plane_handle, DRM_CLOEXEC | DRM_RDWR, &fd);
+
+  // Older DRM implementations blocked DRM_RDWR, but gave a read/write mapping
+  // anyways
+  if (ret)
+    ret = drmPrimeHandleToFD(dev_fd, plane_handle, DRM_CLOEXEC, &fd);
+
+  return ret ? ret : fd;
+}
+
+size_t GetSizeOfPlane(gbm_bo* bo, size_t plane) {
+  // System linux gbm (or Mesa gbm) does not provide plane size. Thus, calculate
+  // it by ourselves and avoid having two different branches for minigbm and
+  // Mesa gbm here.
+  return gbm_bo_get_height(bo) * gbm_bo_get_stride_for_plane(bo, plane);
+}
+
 }  // namespace
 
 class Buffer final : public ui::GbmBuffer {
@@ -84,7 +158,7 @@ class Buffer final : public ui::GbmBuffer {
   }
   uint32_t GetPlaneHandle(size_t plane) const override {
     DCHECK_LT(plane, planes_.size());
-    return gbm_bo_get_plane_handle(bo_, plane).u32;
+    return gbm_bo_get_handle_for_plane(bo_, plane).u32;
   }
   uint32_t GetHandle() const override { return gbm_bo_get_handle(bo_).u32; }
   gfx::NativePixmapHandle ExportHandle() const override {
@@ -114,7 +188,12 @@ class Buffer final : public ui::GbmBuffer {
     uint32_t stride;
     void* addr;
     addr = gbm_bo_map(bo_, 0, 0, gbm_bo_get_width(bo_), gbm_bo_get_height(bo_),
-                      GBM_BO_TRANSFER_READ_WRITE, &stride, &mmap_data_, 0);
+                      GBM_BO_TRANSFER_READ_WRITE, &stride, &mmap_data_
+#if defined(USING_MINIGBM)
+                      ,
+                      0
+#endif
+                      );
 
     if (!addr)
       return nullptr;
@@ -155,11 +234,18 @@ std::unique_ptr<Buffer> CreateBufferForBO(struct gbm_bo* bo,
   std::vector<base::ScopedFD> fds;
   std::vector<gfx::NativePixmapPlane> planes;
 
-  const uint64_t modifier = gbm_bo_get_format_modifier(bo);
-  for (size_t i = 0; i < gbm_bo_get_num_planes(bo); ++i) {
+  const uint64_t modifier = gbm_bo_get_modifier(bo);
+  const int plane_count = gbm_bo_get_plane_count(bo);
+  // The Mesa's gbm implementation explicitly checks whether plane count <= and
+  // returns 1 if the condition is true. Nevertheless, use a DCHECK here to make
+  // sure the condition is not broken there.
+  DCHECK(plane_count > 0);
+  // Ensure there are no differences in integer signs by casting any possible
+  // values to size_t.
+  for (size_t i = 0; i < static_cast<size_t>(plane_count); ++i) {
     // The fd returned by gbm_bo_get_fd is not ref-counted and need to be
     // kept open for the lifetime of the buffer.
-    base::ScopedFD fd(gbm_bo_get_plane_fd(bo, i));
+    base::ScopedFD fd(GetPlaneFdForBo(bo, i));
 
     // TODO(dcastagna): support multiple fds.
     // crbug.com/642410
@@ -172,9 +258,9 @@ std::unique_ptr<Buffer> CreateBufferForBO(struct gbm_bo* bo,
       fds.emplace_back(std::move(fd));
     }
 
-    planes.emplace_back(gbm_bo_get_plane_stride(bo, i),
-                        gbm_bo_get_plane_offset(bo, i),
-                        gbm_bo_get_plane_size(bo, i), modifier);
+    planes.emplace_back(gbm_bo_get_stride_for_plane(bo, i),
+                        gbm_bo_get_offset(bo, i), GetSizeOfPlane(bo, i),
+                        modifier);
   }
   return std::make_unique<Buffer>(bo, format, flags, modifier, std::move(fds),
                                   size, std::move(planes));
@@ -221,41 +307,31 @@ class Device final : public ui::GbmDevice {
     DCHECK_EQ(planes[0].offset, 0);
 
     // Try to use scanout if supported.
-    int gbm_flags = GBM_BO_USE_SCANOUT | GBM_BO_USE_TEXTURING;
+    int gbm_flags = GBM_BO_USE_SCANOUT;
+#if defined(USING_MINIGBM)
+    gbm_flags |= GBM_BO_USE_TEXTURING;
+#endif
     if (!gbm_device_is_format_supported(device_, format, gbm_flags))
       gbm_flags &= ~GBM_BO_USE_SCANOUT;
 
     struct gbm_bo* bo = nullptr;
-    if (!gbm_device_is_format_supported(device_, format, gbm_flags)) {
-      LOG(ERROR) << "gbm format not supported: " << format;
-      return nullptr;
-    }
-
-    struct gbm_import_fd_planar_data fd_data;
-    fd_data.width = size.width();
-    fd_data.height = size.height();
-    fd_data.format = format;
-
-    DCHECK_LE(planes.size(), 3u);
-    for (size_t i = 0; i < planes.size(); ++i) {
-      fd_data.fds[i] = fds[i < fds.size() ? i : 0].get();
-      fd_data.strides[i] = planes[i].stride;
-      fd_data.offsets[i] = planes[i].offset;
-      fd_data.format_modifiers[i] = planes[i].modifier;
-    }
-
-    // The fd passed to gbm_bo_import is not ref-counted and need to be
-    // kept open for the lifetime of the buffer.
-    //
-    // See the comment regarding the GBM_BO_IMPORT_FD_PLANAR_550X above.
-    bo = gbm_bo_import(device_, GBM_BO_IMPORT_FD_PLANAR_5505, &fd_data,
-                       gbm_flags);
-    if (!bo) {
-      bo = gbm_bo_import(device_, GBM_BO_IMPORT_FD_PLANAR_5504, &fd_data,
+    if (gbm_device_is_format_supported(device_, format, gbm_flags)) {
+      gbm_bo_import_fd_data_with_modifier fd_data;
+      InitializeImportData(format, size, fds, planes, &fd_data);
+
+      // The fd passed to gbm_bo_import is not ref-counted and need to be
+      // kept open for the lifetime of the buffer.
+      //
+      // See the comment regarding the GBM_BO_IMPORT_FD_PLANAR_550X above.
+      bo = gbm_bo_import(device_, GBM_BO_IMPORT_FD_PLANAR_5505, &fd_data,
                          gbm_flags);
       if (!bo) {
-        LOG(ERROR) << "nullptr returned from gbm_bo_import";
-        return nullptr;
+        bo = gbm_bo_import(device_, GBM_BO_IMPORT_FD_PLANAR_5504, &fd_data,
+                           gbm_flags);
+        if (!bo) {
+          LOG(ERROR) << "nullptr returned from gbm_bo_import";
+          return nullptr;
+        }
       }
     }
 
