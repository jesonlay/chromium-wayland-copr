From 93b1c54553aed8812c39453ca8d05664f304c127 Mon Sep 17 00:00:00 2001
From: Michael Lippautz <mlippautz@chromium.org>
Date: Mon, 25 Feb 2019 07:29:47 +0000
Subject: [PATCH] ThreadState: Split off scopes and remove dead code

Change-Id: I273f6ffc061bd1ba9f924de39e11cd2aa26baf21
Reviewed-on: https://chromium-review.googlesource.com/c/1484093
Commit-Queue: Michael Lippautz <mlippautz@chromium.org>
Reviewed-by: Kentaro Hara <haraken@chromium.org>
Cr-Commit-Position: refs/heads/master@{#635042}
---
 .../bindings/core/v8/v8_script_runner.cc      |   2 -
 .../script_wrappable_marking_visitor.cc       |   4 -
 .../blink/renderer/platform/heap/BUILD.gn     |   1 +
 .../blink/renderer/platform/heap/heap.cc      |   2 +-
 .../renderer/platform/heap/heap_allocator.h   |   1 +
 .../renderer/platform/heap/thread_state.cc    |  10 +-
 .../renderer/platform/heap/thread_state.h     | 154 +++---------------
 .../heap/thread_state_scheduling_test.cc      |   2 +-
 .../platform/heap/thread_state_scopes.h       | 110 +++++++++++++
 9 files changed, 141 insertions(+), 145 deletions(-)
 create mode 100644 third_party/blink/renderer/platform/heap/thread_state_scopes.h

diff --git a/third_party/blink/renderer/bindings/core/v8/v8_script_runner.cc b/third_party/blink/renderer/bindings/core/v8/v8_script_runner.cc
index eadfc8629aae8..4c4fe34f5cb26 100644
--- a/third_party/blink/renderer/bindings/core/v8/v8_script_runner.cc
+++ b/third_party/blink/renderer/bindings/core/v8/v8_script_runner.cc
@@ -444,7 +444,6 @@ v8::MaybeLocal<v8::Value> V8ScriptRunner::CallFunction(
   DCHECK(!frame || BindingSecurity::ShouldAllowAccessToFrame(
                        ToLocalDOMWindow(function->CreationContext()), frame,
                        BindingSecurity::ErrorReportOption::kDoNotReport));
-  CHECK(!ThreadState::Current()->IsWrapperTracingForbidden());
   v8::Isolate::SafeForTerminationScope safe_for_termination(isolate);
   v8::MicrotasksScope microtasks_scope(isolate,
                                        v8::MicrotasksScope::kRunMicrotasks);
@@ -474,7 +473,6 @@ v8::MaybeLocal<v8::Value> V8ScriptRunner::CallInternalFunction(
   RuntimeCallStatsScopedTracer rcs_scoped_tracer(isolate);
   RUNTIME_CALL_TIMER_SCOPE(isolate, RuntimeCallStats::CounterId::kV8);
 
-  CHECK(!ThreadState::Current()->IsWrapperTracingForbidden());
   v8::Isolate::SafeForTerminationScope safe_for_termination(isolate);
   v8::MicrotasksScope microtasks_scope(
       isolate, v8::MicrotasksScope::kDoNotRunMicrotasks);
diff --git a/third_party/blink/renderer/platform/bindings/script_wrappable_marking_visitor.cc b/third_party/blink/renderer/platform/bindings/script_wrappable_marking_visitor.cc
index 5b55814aa3bbc..03f615b348544 100644
--- a/third_party/blink/renderer/platform/bindings/script_wrappable_marking_visitor.cc
+++ b/third_party/blink/renderer/platform/bindings/script_wrappable_marking_visitor.cc
@@ -29,7 +29,6 @@ void ScriptWrappableMarkingVisitor::TracePrologue() {
   // This CHECK ensures that wrapper tracing is not started from scopes
   // that forbid GC execution, e.g., constructors.
   CHECK(ThreadState::Current());
-  CHECK(!ThreadState::Current()->IsWrapperTracingForbidden());
   PerformCleanup();
 
   CHECK(!tracing_in_progress_);
@@ -43,14 +42,12 @@ void ScriptWrappableMarkingVisitor::TracePrologue() {
 
 void ScriptWrappableMarkingVisitor::EnterFinalPause(EmbedderStackState) {
   CHECK(ThreadState::Current());
-  CHECK(!ThreadState::Current()->IsWrapperTracingForbidden());
   ThreadState::Current()->DisableWrapperTracingBarrier();
   ActiveScriptWrappableBase::TraceActiveScriptWrappables(isolate(), this);
 }
 
 void ScriptWrappableMarkingVisitor::TraceEpilogue() {
   CHECK(ThreadState::Current());
-  CHECK(!ThreadState::Current()->IsWrapperTracingForbidden());
   DCHECK(marking_deque_.IsEmpty());
 #if DCHECK_IS_ON()
   ScriptWrappableVisitorVerifier verifier(ThreadState::Current());
@@ -180,7 +177,6 @@ bool ScriptWrappableMarkingVisitor::AdvanceTracing(double deadline_in_ms) {
   // perform a GC. This makes sure that TraceTraits and friends find
   // themselves in a well-defined environment, e.g., properly set up vtables.
   CHECK(ThreadState::Current());
-  CHECK(!ThreadState::Current()->IsWrapperTracingForbidden());
   CHECK(tracing_in_progress_);
   TimeTicks deadline =
       TimeTicks() + TimeDelta::FromMillisecondsD(deadline_in_ms);
diff --git a/third_party/blink/renderer/platform/heap/BUILD.gn b/third_party/blink/renderer/platform/heap/BUILD.gn
index 197d649e9ffa4..ed62cd53746a8 100644
--- a/third_party/blink/renderer/platform/heap/BUILD.gn
+++ b/third_party/blink/renderer/platform/heap/BUILD.gn
@@ -75,6 +75,7 @@ blink_platform_sources("heap") {
     "stack_frame_depth.h",
     "thread_state.cc",
     "thread_state.h",
+    "thread_state_scopes.h",
     "threading_traits.h",
     "trace_traits.h",
     "unified_heap_controller.cc",
diff --git a/third_party/blink/renderer/platform/heap/heap.cc b/third_party/blink/renderer/platform/heap/heap.cc
index cf507ab338a7d..ad950a9c4e09c 100644
--- a/third_party/blink/renderer/platform/heap/heap.cc
+++ b/third_party/blink/renderer/platform/heap/heap.cc
@@ -44,7 +44,7 @@
 #include "third_party/blink/renderer/platform/heap/marking_visitor.h"
 #include "third_party/blink/renderer/platform/heap/page_memory.h"
 #include "third_party/blink/renderer/platform/heap/page_pool.h"
-#include "third_party/blink/renderer/platform/heap/thread_state.h"
+#include "third_party/blink/renderer/platform/heap/thread_state_scopes.h"
 #include "third_party/blink/renderer/platform/histogram.h"
 #include "third_party/blink/renderer/platform/instrumentation/tracing/trace_event.h"
 #include "third_party/blink/renderer/platform/instrumentation/tracing/web_memory_allocator_dump.h"
diff --git a/third_party/blink/renderer/platform/heap/heap_allocator.h b/third_party/blink/renderer/platform/heap/heap_allocator.h
index 01d96002e48e3..b18be98310eb5 100644
--- a/third_party/blink/renderer/platform/heap/heap_allocator.h
+++ b/third_party/blink/renderer/platform/heap/heap_allocator.h
@@ -10,6 +10,7 @@
 #include "third_party/blink/renderer/platform/heap/heap.h"
 #include "third_party/blink/renderer/platform/heap/heap_buildflags.h"
 #include "third_party/blink/renderer/platform/heap/marking_visitor.h"
+#include "third_party/blink/renderer/platform/heap/thread_state_scopes.h"
 #include "third_party/blink/renderer/platform/heap/trace_traits.h"
 #include "third_party/blink/renderer/platform/wtf/allocator.h"
 #include "third_party/blink/renderer/platform/wtf/assertions.h"
diff --git a/third_party/blink/renderer/platform/heap/thread_state.cc b/third_party/blink/renderer/platform/heap/thread_state.cc
index 05e8673043d84..7c2781590c8c1 100644
--- a/third_party/blink/renderer/platform/heap/thread_state.cc
+++ b/third_party/blink/renderer/platform/heap/thread_state.cc
@@ -53,6 +53,7 @@
 #include "third_party/blink/renderer/platform/heap/marking_visitor.h"
 #include "third_party/blink/renderer/platform/heap/page_pool.h"
 #include "third_party/blink/renderer/platform/heap/persistent.h"
+#include "third_party/blink/renderer/platform/heap/thread_state_scopes.h"
 #include "third_party/blink/renderer/platform/heap/unified_heap_marking_visitor.h"
 #include "third_party/blink/renderer/platform/heap/visitor.h"
 #include "third_party/blink/renderer/platform/histogram.h"
@@ -171,22 +172,13 @@ ThreadState::ThreadState()
       weak_persistent_region_(std::make_unique<PersistentRegion>()),
       start_of_stack_(reinterpret_cast<intptr_t*>(WTF::GetStackStart())),
       end_of_stack_(reinterpret_cast<intptr_t*>(WTF::GetStackStart())),
-      sweep_forbidden_(false),
-      no_allocation_count_(0),
-      gc_forbidden_count_(0),
-      mixins_being_constructed_count_(0),
-      object_resurrection_forbidden_(false),
-      in_atomic_pause_(false),
       gc_state_(kNoGCScheduled),
       gc_phase_(GCPhase::kNone),
       reason_for_scheduled_gc_(BlinkGC::GCReason::kMaxValue),
-      should_optimize_for_load_time_(false),
       isolate_(nullptr),
       trace_dom_wrappers_(nullptr),
       invalidate_dead_objects_in_wrappers_marking_deque_(nullptr),
       perform_cleanup_(nullptr),
-      wrapper_tracing_(false),
-      incremental_marking_(false),
 #if defined(ADDRESS_SANITIZER)
       asan_fake_stack_(__asan_get_current_fake_stack()),
 #endif
diff --git a/third_party/blink/renderer/platform/heap/thread_state.h b/third_party/blink/renderer/platform/heap/thread_state.h
index d71699706f84d..a045e5c385a97 100644
--- a/third_party/blink/renderer/platform/heap/thread_state.h
+++ b/third_party/blink/renderer/platform/heap/thread_state.h
@@ -167,56 +167,12 @@ class PLATFORM_EXPORT ThreadState final
     kSweeping,
   };
 
-  // The NoAllocationScope class is used in debug mode to catch unwanted
-  // allocations. E.g. allocations during GC.
-  class NoAllocationScope final {
-    STACK_ALLOCATED();
-
-   public:
-    explicit NoAllocationScope(ThreadState* state) : state_(state) {
-      state_->EnterNoAllocationScope();
-    }
-    ~NoAllocationScope() { state_->LeaveNoAllocationScope(); }
-
-   private:
-    ThreadState* state_;
-  };
-
-  class SweepForbiddenScope final {
-    STACK_ALLOCATED();
-
-   public:
-    explicit SweepForbiddenScope(ThreadState* state) : state_(state) {
-      DCHECK(!state_->sweep_forbidden_);
-      state_->sweep_forbidden_ = true;
-    }
-    ~SweepForbiddenScope() {
-      DCHECK(state_->sweep_forbidden_);
-      state_->sweep_forbidden_ = false;
-    }
-
-   private:
-    ThreadState* state_;
-  };
-
-  // Used to denote when access to unmarked objects is allowed but we shouldn't
-  // ressurect it by making new references (e.g. during weak processing and pre
-  // finalizer).
-  class ObjectResurrectionForbiddenScope final {
-    STACK_ALLOCATED();
-
-   public:
-    explicit ObjectResurrectionForbiddenScope(ThreadState* state)
-        : state_(state) {
-      state_->EnterObjectResurrectionForbiddenScope();
-    }
-    ~ObjectResurrectionForbiddenScope() {
-      state_->LeaveObjectResurrectionForbiddenScope();
-    }
-
-   private:
-    ThreadState* state_;
-  };
+  class AtomicPauseScope;
+  class GCForbiddenScope;
+  class MainThreadGCForbiddenScope;
+  class NoAllocationScope;
+  class ObjectResurrectionForbiddenScope;
+  class SweepForbiddenScope;
 
   // Returns true if some thread (possibly the current thread) may be doing
   // incremental marking. If false is returned, the *current* thread is
@@ -326,21 +282,12 @@ class PLATFORM_EXPORT ThreadState final
   }
   void EnterNoAllocationScope() { no_allocation_count_++; }
   void LeaveNoAllocationScope() { no_allocation_count_--; }
-  bool IsWrapperTracingForbidden() { return IsMixinInConstruction(); }
-  bool IsGCForbidden() const {
-    return gc_forbidden_count_ || IsMixinInConstruction();
-  }
+  bool IsGCForbidden() const { return gc_forbidden_count_; }
   void EnterGCForbiddenScope() { gc_forbidden_count_++; }
   void LeaveGCForbiddenScope() {
     DCHECK_GT(gc_forbidden_count_, 0u);
     gc_forbidden_count_--;
   }
-  bool IsMixinInConstruction() const { return mixins_being_constructed_count_; }
-  void EnterMixinConstructionScope() { mixins_being_constructed_count_++; }
-  void LeaveMixinConstructionScope() {
-    DCHECK_GT(mixins_being_constructed_count_, 0u);
-    mixins_being_constructed_count_--;
-  }
   bool SweepForbidden() const { return sweep_forbidden_; }
   bool IsObjectResurrectionForbidden() const {
     return object_resurrection_forbidden_;
@@ -375,49 +322,6 @@ class PLATFORM_EXPORT ThreadState final
   bool IsIncrementalMarking() const { return incremental_marking_; }
   void SetIncrementalMarking(bool value) { incremental_marking_ = value; }
 
-  class MainThreadGCForbiddenScope final {
-    STACK_ALLOCATED();
-
-   public:
-    MainThreadGCForbiddenScope()
-        : thread_state_(ThreadState::MainThreadState()) {
-      thread_state_->EnterGCForbiddenScope();
-    }
-    ~MainThreadGCForbiddenScope() { thread_state_->LeaveGCForbiddenScope(); }
-
-   private:
-    ThreadState* const thread_state_;
-  };
-
-  class GCForbiddenScope final {
-    STACK_ALLOCATED();
-
-   public:
-    explicit GCForbiddenScope(ThreadState* thread_state)
-        : thread_state_(thread_state) {
-      thread_state_->EnterGCForbiddenScope();
-    }
-    ~GCForbiddenScope() { thread_state_->LeaveGCForbiddenScope(); }
-
-   private:
-    ThreadState* const thread_state_;
-  };
-
-  // Used to mark when we are in an atomic pause for GC.
-  class AtomicPauseScope final {
-   public:
-    explicit AtomicPauseScope(ThreadState* thread_state)
-        : thread_state_(thread_state), gc_forbidden_scope(thread_state) {
-      thread_state_->EnterAtomicPause();
-    }
-    ~AtomicPauseScope() { thread_state_->LeaveAtomicPause(); }
-
-   private:
-    ThreadState* const thread_state_;
-    ScriptForbiddenScope script_forbidden_scope;
-    GCForbiddenScope gc_forbidden_scope;
-  };
-
   void FlushHeapDoesNotContainCacheIfNeeded();
 
   void SafePoint(BlinkGC::StackState);
@@ -543,6 +447,16 @@ class PLATFORM_EXPORT ThreadState final
   // Same semantic as |incremental_marking_flag_|.
   static AtomicEntryFlag wrapper_tracing_flag_;
 
+  static WTF::ThreadSpecific<ThreadState*>* thread_specific_;
+
+  // We can't create a static member of type ThreadState here because it will
+  // introduce global constructor and destructor. We would like to manage
+  // lifetime of the ThreadState attached to the main thread explicitly instead
+  // and still use normal constructor and destructor for the ThreadState class.
+  // For this we reserve static storage for the main ThreadState and lazily
+  // construct ThreadState in it using placement new.
+  static uint8_t main_thread_state_storage_[];
+
   ThreadState();
   ~ThreadState() override;
 
@@ -630,9 +544,6 @@ class PLATFORM_EXPORT ThreadState final
 
   void ReportMemoryToV8();
 
-
-  friend class BlinkGCObserver;
-
   // Adds the given observer to the ThreadState's observer list. This doesn't
   // take ownership of the argument. The argument must not be null. The argument
   // must not be registered before calling this.
@@ -643,17 +554,6 @@ class PLATFORM_EXPORT ThreadState final
   // The argument must be registered before calling this.
   void RemoveObserver(BlinkGCObserver*);
 
-  static WTF::ThreadSpecific<ThreadState*>* thread_specific_;
-
-  // We can't create a static member of type ThreadState here
-  // because it will introduce global constructor and destructor.
-  // We would like to manage lifetime of the ThreadState attached
-  // to the main thread explicitly instead and still use normal
-  // constructor and destructor for the ThreadState class.
-  // For this we reserve static storage for the main ThreadState
-  // and lazily construct ThreadState in it using placement new.
-  static uint8_t main_thread_state_storage_[];
-
   std::unique_ptr<ThreadHeap> heap_;
   base::PlatformThreadId thread_;
   std::unique_ptr<PersistentRegion> persistent_region_;
@@ -661,12 +561,14 @@ class PLATFORM_EXPORT ThreadState final
   intptr_t* start_of_stack_;
   intptr_t* end_of_stack_;
 
-  bool sweep_forbidden_;
-  size_t no_allocation_count_;
-  size_t gc_forbidden_count_;
-  size_t mixins_being_constructed_count_;
-  bool object_resurrection_forbidden_;
-  bool in_atomic_pause_;
+  bool object_resurrection_forbidden_ = false;
+  bool in_atomic_pause_ = false;
+  bool sweep_forbidden_ = false;
+  bool wrapper_tracing_ = false;
+  bool incremental_marking_ = false;
+  bool should_optimize_for_load_time_ = false;
+  size_t no_allocation_count_ = 0;
+  size_t gc_forbidden_count_ = 0;
 
   TimeDelta next_incremental_marking_step_duration_;
   TimeDelta previous_incremental_marking_time_left_;
@@ -675,8 +577,6 @@ class PLATFORM_EXPORT ThreadState final
   GCPhase gc_phase_;
   BlinkGC::GCReason reason_for_scheduled_gc_;
 
-  bool should_optimize_for_load_time_;
-
   using PreFinalizerCallback = bool (*)(void*);
   using PreFinalizer = std::pair<void*, PreFinalizerCallback>;
 
@@ -689,8 +589,6 @@ class PLATFORM_EXPORT ThreadState final
   void (*trace_dom_wrappers_)(v8::Isolate*, Visitor*);
   void (*invalidate_dead_objects_in_wrappers_marking_deque_)(v8::Isolate*);
   void (*perform_cleanup_)(v8::Isolate*);
-  bool wrapper_tracing_;
-  bool incremental_marking_;
 
 #if defined(ADDRESS_SANITIZER)
   void* asan_fake_stack_;
@@ -721,7 +619,7 @@ class PLATFORM_EXPORT ThreadState final
   };
   GCData current_gc_data_;
 
-  // Needs to set up visitor for testing purposes.
+  friend class BlinkGCObserver;
   friend class incremental_marking_test::IncrementalMarkingScope;
   friend class incremental_marking_test::IncrementalMarkingTestDriver;
   template <typename T>
diff --git a/third_party/blink/renderer/platform/heap/thread_state_scheduling_test.cc b/third_party/blink/renderer/platform/heap/thread_state_scheduling_test.cc
index a4818fdb32ac1..e1119d56c4dc8 100644
--- a/third_party/blink/renderer/platform/heap/thread_state_scheduling_test.cc
+++ b/third_party/blink/renderer/platform/heap/thread_state_scheduling_test.cc
@@ -4,7 +4,7 @@
 
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/blink/renderer/platform/heap/heap_test_utilities.h"
-#include "third_party/blink/renderer/platform/heap/thread_state.h"
+#include "third_party/blink/renderer/platform/heap/thread_state_scopes.h"
 #include "third_party/blink/renderer/platform/runtime_enabled_features.h"
 
 namespace blink {
diff --git a/third_party/blink/renderer/platform/heap/thread_state_scopes.h b/third_party/blink/renderer/platform/heap/thread_state_scopes.h
new file mode 100644
index 0000000000000..3233252180af0
--- /dev/null
+++ b/third_party/blink/renderer/platform/heap/thread_state_scopes.h
@@ -0,0 +1,110 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_HEAP_THREAD_STATE_SCOPES_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_HEAP_THREAD_STATE_SCOPES_H_
+
+#include "third_party/blink/renderer/platform/heap/thread_state.h"
+
+namespace blink {
+
+// The NoAllocationScope class is used in debug mode to catch unwanted
+// allocations. E.g. allocations during GC.
+class ThreadState::NoAllocationScope final {
+  STACK_ALLOCATED();
+  DISALLOW_COPY_AND_ASSIGN(NoAllocationScope);
+
+ public:
+  explicit NoAllocationScope(ThreadState* state) : state_(state) {
+    state_->EnterNoAllocationScope();
+  }
+  ~NoAllocationScope() { state_->LeaveNoAllocationScope(); }
+
+ private:
+  ThreadState* const state_;
+};
+
+class ThreadState::SweepForbiddenScope final {
+  STACK_ALLOCATED();
+  DISALLOW_COPY_AND_ASSIGN(SweepForbiddenScope);
+
+ public:
+  explicit SweepForbiddenScope(ThreadState* state) : state_(state) {
+    DCHECK(!state_->sweep_forbidden_);
+    state_->sweep_forbidden_ = true;
+  }
+  ~SweepForbiddenScope() {
+    DCHECK(state_->sweep_forbidden_);
+    state_->sweep_forbidden_ = false;
+  }
+
+ private:
+  ThreadState* const state_;
+};
+
+// Used to denote when access to unmarked objects is allowed but we shouldn't
+// resurrect it by making new references (e.g. during weak processing and pre
+// finalizer).
+class ThreadState::ObjectResurrectionForbiddenScope final {
+  STACK_ALLOCATED();
+  DISALLOW_COPY_AND_ASSIGN(ObjectResurrectionForbiddenScope);
+
+ public:
+  explicit ObjectResurrectionForbiddenScope(ThreadState* state)
+      : state_(state) {
+    state_->EnterObjectResurrectionForbiddenScope();
+  }
+  ~ObjectResurrectionForbiddenScope() {
+    state_->LeaveObjectResurrectionForbiddenScope();
+  }
+
+ private:
+  ThreadState* const state_;
+};
+
+class ThreadState::MainThreadGCForbiddenScope final {
+  STACK_ALLOCATED();
+
+ public:
+  MainThreadGCForbiddenScope() : thread_state_(ThreadState::MainThreadState()) {
+    thread_state_->EnterGCForbiddenScope();
+  }
+  ~MainThreadGCForbiddenScope() { thread_state_->LeaveGCForbiddenScope(); }
+
+ private:
+  ThreadState* const thread_state_;
+};
+
+class ThreadState::GCForbiddenScope final {
+  STACK_ALLOCATED();
+
+ public:
+  explicit GCForbiddenScope(ThreadState* thread_state)
+      : thread_state_(thread_state) {
+    thread_state_->EnterGCForbiddenScope();
+  }
+  ~GCForbiddenScope() { thread_state_->LeaveGCForbiddenScope(); }
+
+ private:
+  ThreadState* const thread_state_;
+};
+
+// Used to mark when we are in an atomic pause for GC.
+class ThreadState::AtomicPauseScope final {
+ public:
+  explicit AtomicPauseScope(ThreadState* thread_state)
+      : thread_state_(thread_state), gc_forbidden_scope(thread_state) {
+    thread_state_->EnterAtomicPause();
+  }
+  ~AtomicPauseScope() { thread_state_->LeaveAtomicPause(); }
+
+ private:
+  ThreadState* const thread_state_;
+  ScriptForbiddenScope script_forbidden_scope;
+  GCForbiddenScope gc_forbidden_scope;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_HEAP_THREAD_STATE_SCOPES_H_
